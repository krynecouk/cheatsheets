* Primitives
** Integers
   ~iex> 244~
** Floats
   ~iex> 3.14~
   ~iex> .14~ # error
** Booleans
   ~iex> true~
   ~iex> false~
   - everything is ~true~ except for ~false~ and ~nil~
** Atoms
   ~iex> :foo~
   - constant whose name is its value (~:foo~)
   - analogy to ~Symbol~ in Ruby
   - /"It would be much simpler if we stored identical strings at the same location in memory. Then, checking equality would be a simple pointer or index comparison."/ ([[https://stackoverflow.com/questions/32261500/why-is-useful-to-have-a-atom-type-like-in-elixir-erlang][source]])
** String
   ~iex> "foo"~
* Basic Operations
** Boolean
*** ~||~, ~&&~, ~!~
    ~iex> -20 || true~ #true
    ~iex> nil || "foo"~ #"foo"
    ~iex> "foo" && :bar~ #:bar
    ~iex> false && :bar~ #false
*** ~and~ (~andalso), ~or~ (~orelse), ~not~
    - first argument *must* be ~boolean~
    ~iex> true and 42 #42~
    ~iex> false or true #true~
    ~iex> not false #true~
    ~iex> 42 and true #** (ArgumentError) argument error: 42~
    ~iex> not 42 ** (ArgumentError) argument error~
** Comparison
   ~==~, ~!=~, ~===~, ~!==~, ~<=~, ~>=~, ~<~ and ~>~
*** Comparison order
    number < atom < reference < function < port < pid < tuple < map < list < bitstring
*** String number comparison
    ~iex> 2 == 2.0~ #true
    ~iex> 2 === 2.0~ #false
** String Interpolation
   #+BEGIN_SRC elixir
   name = "Sean"
   "Hello #{name}"
   #+END_SRC
* Collections
** Lists
   #+BEGIN_SRC elixir
   list = [3.14, :pie, "Apple"]
   #+END_SRC
*** Prepending (fast)
    #+BEGIN_SRC elixir
    list = [3.14, :pie, "Apple"]
    ["Ï€" | list]
    #+END_SRC
*** Appending (slow)
    #+BEGIN_SRC elixir
    list = [3.14, :pie, "Apple"]
    list ++ ["Cherry"]
    #+END_SRC
*** Concatenation
    #+BEGIN_SRC elixir
    [1, 2] ++ [3, 4, 1]
    #+END_SRC
*** Substraction
    #+BEGIN_SRC elixir
    ["foo", :bar, 42] -- [42, "bar"]
    #+END_SRC
    #+BEGIN_SRC elixir
    [1,2,2,3,2,3] -- [1,2,3,2]
    #+END_SRC
*** Head
    #+BEGIN_SRC elixir
    hd [3.14, :pie, "Apple"]
    #+END_SRC
*** Tail
    #+BEGIN_SRC elixir
    tl [3.14, :pie, "Apple"]
    #+END_SRC
*** Head/Tail with Pattern Matching
    #+BEGIN_SRC elixir
    [head | tail] = [3.14, :pie, "Apple"]
    #+END_SRC
** Tuples
   #+BEGIN_SRC elixir
   {3.14, :pie, "Apple"}
   #+END_SRC
** Keyword Lists
   Special list of two-element tuples whose first element is an atom. Mostly used for pass options to functions.
   #+BEGIN_SRC elixir
   [{:foo, "bar"}, {:hello, "world"}]
   #+END_SRC
   #+BEGIN_SRC elixir
   [foo: "bar", hello: "world"]
   #+END_SRC
   - Keys are atoms.
   - Keys are ordered.
   - Keys do not have to be unique.
** Maps
*** READ
   #+BEGIN_SRC elixir
   map = %{:foo => "bar", "hello" => :world}
   %{:foo => "bar", "hello" => :world}
   map[:foo]
   #map["hello"]
   #map.hello #only for atom keys
   #+END_SRC
*** UPDATE (existing)
   #+BEGIN_SRC elixir
   map = %{foo: "bar", hello: "world"}
   %{map | foo: "baz"}
   #+END_SRC
*** UPDATE (new)
    #+BEGIN_SRC elixir
    map = %{hello: "world"}
    Map.put(map, :foo, "baz")
    #+END_SRC
* Enum
  Enumeration is at the core of functional programming ([[https://hexdocs.pm/elixir/Enum.html][Enum Docs]], [[https://hexdocs.pm/elixir/Stream.html][Stream Docs]]).
** ~all?/2~
   All must be ~true~ to return ~true~.
   #+BEGIN_SRC elixir
   Enum.all?(["foo", "bar", "hello"], fn(s) -> String.length(s) == 3 end) # false
   Enum.all?(["foo", "bar", "hello"], fn(s) -> String.length(s) > 1 end) # true
   #+END_SRC
** ~any?/2~
   Any must be ~true~ to return ~true~.
   #+BEGIN_SRC elixir
   Enum.any?(["foo", "bar", "hello"], fn(s) -> String.length(s) == 5 end)
   #+END_SRC
** ~chunk_every/2~
   Creates chunk based on the size of second argument.
   #+BEGIN_SRC elixir
   Enum.chunk_every([1, 2, 3, 4, 5, 6], 2)
   #+END_SRC
** ~chunk_by/2~
   Creates chunk when return of function is different than previous call.
   #+BEGIN_SRC elixir
   Enum.chunk_by(["one", "two", "three", "four", "five"], fn(x) -> String.length(x) end)
   #+END_SRC
** ~map_every/3~
   Apply function on every nth (including first) argument with provided function.
   #+BEGIN_SRC elixir
   Enum.map_every([1, 2, 3, 4, 5, 6, 7, 8], 3, fn x -> x + 1000 end)
   #+END_SRC
** ~each/2~
   #+BEGIN_SRC elixir
   Enum.each(["one", "two", "three"], fn(s) -> IO.puts(s) end)
   #+END_SRC
** ~map/2~
   #+BEGIN_SRC elixir
   Enum.map([0, 1, 2, 3], fn(x) -> x - 1 end)
   #+END_SRC
** ~min/1~
   #+BEGIN_SRC elixir
   Enum.min([5, 3, 0, -1])
   #+END_SRC
** ~max/1~
   #+BEGIN_SRC elixir
   Enum.max([5, 3, 0, -1])
   #+END_SRC
** ~filter/2~
   #+BEGIN_SRC elixir
   Enum.filter([1, 2, 3, 4], fn(x) -> rem(x, 2) == 0 end)
   #+END_SRC
** ~reduce/3~
   Accumulator (second argument) is optional. If none is provided than first value is accumulator.
   #+BEGIN_SRC elixir
   Enum.reduce([1, 2, 3], 10, fn(x, acc) -> x + acc end)
   #+END_SRC
** ~sort/1~ (default sorter)
   #+BEGIN_SRC elixir
   Enum.sort([5, 6, 1, 3, -1, 4])
   #+END_SRC
** ~sort/2~ (custom sorter)
   If ~x~ before ~y~ then ~fn~ must return ~true~.
   #+BEGIN_SRC elixir
   Enum.sort([%{:val => 4}, %{:val => 1}], fn(x, y) -> x[:val] > y[:val] end)
   #+END_SRC
** ~uniq/1~
   #+BEGIN_SRC elixir
   Enum.uniq([1, 2, 3, 2, 1, 1, 1, 1, 1])
   #+END_SRC
** ~uniq_by/2~
   #+BEGIN_SRC elixir
   Enum.uniq_by([%{x: 1, y: 1}, %{x: 2, y: 1}, %{x: 3, y: 3}], fn coord -> coord.y end)
   #+END_SRC
* Pattern Matching
** Match Operator
   ~=~ is a *match* operator, *NOT* assignment operator. If match succeeds, it returns value of the equation.
   The match operator performs assignment only when the left side of the match includes a variable.
   #+BEGIN_SRC elixir
   x = 1
   1 = x
   # 2 = x # Error
   #+END_SRC

   Example #1:
   #+BEGIN_SRC elixir
   list = [1, 2, 3]
   [1, 2, 3] = list
   # [] = list # Error
   #+END_SRC

   Example #2:
   #+BEGIN_SRC elixir
   list = [1, 2, 3]
   [1 | tail] = list
   tail # [2, 3]
   # [2 | _] = list # Error
   #+END_SRC

   Example #3:
   #+BEGIN_SRC elixir
   {:ok, value} = {:ok, "Successful!"}
   value # "Successful!"
   # {:ok, value} = {:error} # Error
   #+END_SRC
** Pin Operator
   Match operator performs assignements if left side of matching is variable. Forbid this behavior with =pin= operator.

   Example #1:
   #+BEGIN_SRC elixir
   x = 1
   ^x = 2
   #+END_SRC

   Example #2:
   #+BEGIN_SRC elixir
   x = 1
   {x, ^x} = {2, 1}
   x
   #+END_SRC

   Example #3:
   #+BEGIN_SRC elixir
   key = "hello"
   %{^key => value} = %{"hello" => "world"}
   # %{^key => value} = %{:hello => "world"} # Error
   #+END_SRC
* Control Structures
** ~if/2~
   #+BEGIN_SRC elixir
   if String.valid?("Hello") do
     "Valid string!"
   else
     "Invalid string."
   end
   #+END_SRC
** ~unless/2~
   #+BEGIN_SRC elixir
   unless is_integer("hello") do
     "Not an Int"
   end
   #+END_SRC
** ~case/2~
   #+BEGIN_SRC elixir
   case {:ok, "Hello World"} do
     {:ok, result} -> result
     {:error} -> "Uh oh!"
     _ -> "Catch all"
   end
   #+END_SRC
