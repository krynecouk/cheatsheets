#+TITLE: C++
* Compilers
- gcc
- g++
- clang
- clang++
** How to upgrade to v7?
#+BEGIN_SRC sh
sudo add-apt-repository ppa:ubuntu-toolchain-r/test
sudo apt-get update
sudo apt-get install gcc-7 g++-7
sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-7 20 --slave /usr/bin/g++ g++ /usr/bin/g++-7
#+END_SRC
** How to compile with asm output?
#+BEGIN_SRC sh
g++ -S <file.cpp>
#+END_SRC
** How to get readable asm output?
#+BEGIN_SRC sh
g++ -O0 -S main.cpp
# +END_SRC
or
,#+BEGIN_SRC sh
g++ -g -c main.cpp && objdump -d -M intel -S main.o
#+END_SRC
* Namespaces
#+BEGIN_SRC cpp
#include <iostream>
int main() {
  std::cout << "Foo";
}
#+END_SRC
or
#+BEGIN_SRC cpp
#include <iostream>
using namespace std;
int main() {
  cout << "Foo";
}
#+END_SRC
or
#+BEGIN_SRC cpp
#include <iostream>
using std::cout;
int main() {
  cout << "Foo";
}
#+END_SRC
* ~cout~
Console output stream.
#+BEGIN_SRC cpp
cout << "foo"; // insertion operator
#+END_SRC
* ~cin~
Console input stream.
#+BEGIN_SRC cpp
string foo;
cin >> foo; // extraction operator
#+END_SRC
* Variable Initializations
#+BEGIN_SRC cpp
int i = 20; // asignement
int i (20); // constructor
int i {20}; // initialization
#+END_SRC
* Primitive Types
|------------------------+-------------------+---------------------------------|
| Type                   | Typical Bit Width | Typical Range                   |
|------------------------+-------------------+---------------------------------|
| char                   | 1byte             | -127 to 127 or 0 to 255         |
| unsigned char          | 1byte             | 0 to 255                        |
| signed char            | 1byte             | -127 to 127                     |
| int                    | 4bytes            | -2147483648 to 2147483647       |
| unsigned int           | 4bytes            | 0 to 4294967295                 |
| signed int             | 4bytes            | -2147483648 to 2147483647       |
| short int              | 2bytes            | -32768 to 32767                 |
| unsigned short int     | 2bytes            | 0 to 65,535                     |
| signed short int       | 2bytes            | -32768 to 32767                 |
| long int               | 8bytes            | -2,147,483,648 to 2,147,483,647 |
| signed long int        | 8bytes            | same as long int                |
| unsigned long int      | 8bytes            | 0 to 4,294,967,295              |
| long long int          | 8bytes            | -(2^63) to (2^63)-1             |
| unsigned long long int | 8bytes            | 0 to 18,446,744,073,709,551,615 |
| float                  | 4bytes            |                                 |
| double                 | 8bytes            |                                 |
| long double            | 12bytes           |                                 |
| wchar_t                | 2 or 4 bytes      | 1 wide character                |
| bool                   | 1byte             | false/true                      |
|------------------------+-------------------+---------------------------------|
* Primitive Type Alias
#+BEGIN_SRC cpp
typedef int feet;
feet distance {0};
#+END_SRC
* ~enum~
#+BEGIN_SRC cpp
enum color { red, green, blue } c;
c = blue;
#+END_SRC
* ~bool~
~false~ is 0
~true~ is everything except 0
#+BEGIN_SRC cpp
cout << 2 + 2 == 5;    // 0
cout << std::boolalpha;
cout << 2 + 2 == 5;    // false
#+END_SRC
* ~std::sizeof~
#+BEGIN_SRC cpp
sizeof(char);  // 1 bytes
#+END_SRC
* ~climits~ and ~cfloats~
#+BEGIN_SRC cpp
#+BEGIN_SRC cpp
climits::CHAR_MAX; // 127
#+END_SRC
* Constants
- literal                        // x = 12
- declared (~const~)             // const pi {3.1415}
- expression (~constexpr~)       // constexpr int factorial(int n) {...}
- enumerated (~enum~)            // enum foo {bar} f;
- defined (~#define~)            // #define pi 3.14
* Arrays
Just an address of the first element of the chunk of memory.
#+BEGIN_SRC cpp
int foo [3];           // sized array of 3
int foo [] {1, 2, 3};  // automatically sized array
int foo [3] {0};       // sized and init all to 0
int foo [3] {};        // same as {0}
foo[0] = 20;           // assignement
foo[0];                // reading
int foo [3][4] {}      // 2 dim
int foo [3][4] {
    {1,2,3,4},
    {},
    {},
};
#+END_SRC
* ~std::vector~
#+BEGIN_SRC cpp
std::vector <char> vowels;
std::vector <char> vowels (5);                         // sized 5
std::vector <char> vowels (5, 'a');                    // sized 5 and initialized all to 'a'
std::vector <char> vowels {'a', 'e', 'i', 'o', 'u'};   // sized 5 and initialized
std::vector <vector<char>>;                            // 2 dim vector
vowels[0];
vowels.at(0);                                          // same
vowels.at(2) = 'i';
#+END_SRC
* ~static_cast~
#+BEGIN_SRC cpp
static_cast<double>(12);
(double) 12;             // obsolete
#+END_SRC
* Operator Precedence
|-------------------+-----------------------------------------------------------+-------------------------------------------------+---------------|
| Precedence        | Operator                                                  | Description                                     | Associativity |
|-------------------+-----------------------------------------------------------+-------------------------------------------------+---------------|
| 1                 | ::                                                        | Scope resolution                                | Left-to-right |
| 2                 | a++   a--                                                 | Suffix/postfix increment and decrement          |               |
| type()   type{}   | Functional cast                                           |                                                 |               |
| a()               | Function call                                             |                                                 |               |
| a[]               | Subscript                                                 |                                                 |               |
| .   ->            | Member access                                             |                                                 |               |
| 3                 | ++a   --a                                                 | Prefix increment and decrement                  | Right-to-left |
| +a   -a           | Unary plus and minus                                      |                                                 |               |
| !   ~             | Logical NOT and bitwise NOT                               |                                                 |               |
| (type)            | C-style cast                                              |                                                 |               |
| *a                | Indirection (dereference)                                 |                                                 |               |
| &a                | Address-of                                                |                                                 |               |
| sizeof            | Size-of[note 1]                                           |                                                 |               |
| co_await          | await-expression (C++20)                                  |                                                 |               |
| new   new[]       | Dynamic memory allocation                                 |                                                 |               |
| delete   delete[] | Dynamic memory deallocation                               |                                                 |               |
| 4                 | .*   ->*                                                  | Pointer-to-member                               | Left-to-right |
| 5                 | a*b   a/b   a%b                                           | Multiplication, division, and remainder         |               |
| 6                 | a+b   a-b                                                 | Addition and subtraction                        |               |
| 7                 | <<   >>                                                   | Bitwise left shift and right shift              |               |
| 8                 | <=>                                                       | Three-way comparison operator (since C++20)     |               |
| 9                 | <   <=                                                    | For relational operators < and ≤ respectively   |               |
| >   >=            | For relational operators > and ≥ respectively             |                                                 |               |
| 10                | ==   !=                                                   | For relational operators = and ≠ respectively   |               |
| 11                | &                                                         | Bitwise AND                                     |               |
| 12                | ^                                                         | Bitwise XOR (exclusive or)                      |               |
| 13                | \vert                                                     | Bitwise OR (inclusive or)                       |               |
| 14                | &&                                                        | Logical AND                                     |               |
| 15                | \vert\vert                                                |                                                 | Logical OR    |
| 16                | a?b:c                                                     | Ternary conditional[note 2]                     | Right-to-left |
| throw             | throw operator                                            |                                                 |               |
| co_yield          | yield-expression (C++20)                                  |                                                 |               |
| =                 | Direct assignment (provided by default for C++ classes)   |                                                 |               |
| +=   -=           | Compound assignment by sum and difference                 |                                                 |               |
| *=   /=   %=      | Compound assignment by product, quotient, and remainder   |                                                 |               |
| <<=   >>=         | Compound assignment by bitwise left shift and right shift |                                                 |               |
| &=   ^=           | =                                                         | Compound assignment by bitwise AND, XOR, and OR |               |
| 17                | ,                                                         | Comma                                           | Left-to-right |
|-------------------+-----------------------------------------------------------+-------------------------------------------------+---------------|
* ~auto~
Type inference keyword.
#+BEGIN_SRC cpp
// variables
auto d{ 5.0 };            // double

// functions
auto add(int x, int y) {
    return x + y;         // int
}

// function parameters (C++20)
void addAndPrint(auto x, auto y) {
    std::cout << x + y;
}
#+END_SRC
* Strings
- C style
- C++ style
** C style (array of chars)
- array of characters
- terminated by null character (character with value 0)
- libs: ~[[http://www.cplusplus.com/reference/cstring/][<cstring>]]~ and ~[[http://www.cplusplus.com/reference/cstdlib/][<cstdlib>]]~

#+BEGIN_SRC cpp
char foo [8] {"foo"};   // literal
cout << std::strlen(foo);  // (f | o | o | 0) = 3
#+END_SRC
** C++ style (string object)
#+BEGIN_SRC cpp
#include <string>
using namespace std
string s1;
string s2 {"Frank"};
string s3 {s2};
string s4 {"Frank", 3} // Fra
string s5 {s3, 0, 2}   // Fr
string s6 (3, 'X');    // XXX
#+END_SRC
* ~std::size_t~
- return type of ~sizeof~
- unsigned integer with enough bytes to represent the size of any type
- anything that you need to compare in the loop condition against something that is naturally a ~std::size_t~ itself.
  #+BEGIN_SRC cpp
  for (std::size_t i = 0; i < 10; ++i) {
      // ...
  }
  #+END_SRC
* Function Prototypes
- Way to tell compiler about used functions.
  #+BEGIN_SRC cpp
  int foo(int);
  int foo(int a); // same
  #+END_SRC
* Pass-by-value by default
Function arguments are copies by default. Even for objects (shallow copy).
#+BEGIN_SRC cpp
void change_by_value(string s) { s = "changed"; }
void change_by_ref(string &s) { s = "changed"; }

int main() {
  string s = "original";

  change_by_value(s);
  cout << s << endl; // original

  change_by_ref(s);
  cout << s << endl; // changed
}
#+END_SRC
* Pass-by-reference
Formal parameter will be an alias for the actual parameter.
#+BEGIN_SRC cpp
void foo(int &a, int &b);
#+END_SRC
* Default arguments
Must be tail of the function arguments.
#+BEGIN_SRC cpp
void foo(int bar, int baz = 10);
#+END_SRC
* Function static variable
Variable bound to a function declaration.
#+BEGIN_SRC cpp
void foo() {
    static int bar = 5000;
}
#+END_SRC
* Function overloading
Overloaded function must have different parameters (amount or type). Return value is not considered.
#+BEGIN_SRC cpp
void foo(int bar);
void foo(double baz);
int foo(double baz);  // error
#+END_SRC
* Function stack
|-----------|
| Heap      |
| Stack     |
| Registers |
| Opcodes   |
|-----------|
** c++
#+BEGIN_SRC cpp
int foo(int x, int y) {
  int a = 0;
  int b = x;
  int c = y;
  return 22;
}

int main() { int bar = foo(10, 20); }
#+END_SRC
** assembly
~$ g++ -O0 -S main.cpp~
#+BEGIN_SRC asm
        .file   "main.cpp"
        .text
        .globl  _Z3fooii
        .type   _Z3fooii, @function
_Z3fooii:
.LFB0:
        ;; prologue
        .cfi_startproc
        pushq   %rbp
        .cfi_def_cfa_offset 16
        .cfi_offset 6, -16
        movq    %rsp, %rbp
        ;; main stack frame
        .cfi_def_cfa_register 6
        movl    %edi, -20(%rbp)
        movl    %esi, -24(%rbp)
        movl    $0, -12(%rbp)
        movl    -20(%rbp), %eax
        movl    %eax, -8(%rbp)
        movl    -24(%rbp), %eax
        movl    %eax, -4(%rbp)
        movl    $22, %eax
        ;; epilogue
        popq    %rbp
        .cfi_def_cfa 7, 8
        ret
        .cfi_endproc
.LFE0:
        .size   _Z3fooii, .-_Z3fooii
        .globl  main
        .type   main, @function
main:
.LFB1:
        ;; prologue
        .cfi_startproc
        pushq   %rbp
        .cfi_def_cfa_offset 16
        .cfi_offset 6, -16
        ;; main
        movq    %rsp, %rbp
        .cfi_def_cfa_register 6
        movl    $20, %esi
        movl    $10, %edi
        call    _Z3fooii
        movl    $0, %eax
        ;; epilogue
        popq    %rbp
        .cfi_def_cfa 7, 8
        ret
        .cfi_endproc
.LFE1:
        .size   main, .-main
        .ident  "GCC: (Ubuntu 7.5.0-3ubuntu1~16.04) 7.5.0"
        .section        .note.GNU-stack,"",@progbits
#+END_SRC
- ~call~ instruction pushes the current instruction pointer onto the stack and then jumps to the address provided in its argument
 - ~cfi_def_cfa_offset~ (CFA) is defined to be the value of the stack pointer at the call site in the previous frame
- Heap runs in the same memory space as the stack, just on the other end of memory.
- There is absolutely no difference between data in the heap and the stack, except for its location in the memory space.

** table
|----+----------+------------------------------------------+----------------|
|    | [ebp]    | pushq   %rbp                             |                |
|----+----------+------------------------------------------+----------------|
| 20 | [ebp-4]  | movl    -24(%rbp), %eax                  | c              |
|    |          | movl    %eax, -4(%rbp)                   |                |
|    |          |                                          |                |
| 10 | [ebp-8]  | movl    -20(%rbp), %eax                  | b              |
|    |          | movl    %eax, -8(%rbp)                   |                |
|    |          |                                          |                |
|  0 | [ebp-12] | movl   $0, -12(%rbp)                     | a              |
|    |          |                                          |                |
|----+----------+------------------------------------------+----------------|
|    | [esp]    | sub    rsp,0x10 / .cfi_def_cfa_offset 16 |                |
|    | [ebp]    | movq    %rsp, %rbp                       |                |
|----+----------+------------------------------------------+----------------|
| rT | [ebp-16] | call    _Z3fooii                         | return address |
|    |          |                                          |                |
| 10 | [ebp-20] | movl    $10, %edi                        | argument#1     |
|    |          | movl    %edi, -20(%rbp)                  |                |
|    |          |                                          |                |
| 20 | [ebp-24] | movl    $20, %esi                        | argument#2     |
|    |          | movl    %esi, -24(%rbp)                  |                |
|----+----------+------------------------------------------+----------------|
* Operator Overload
#+bEGIN_SRC cpp
class Box {
   public:
      // Overload + operator to add two Box objects.
      Box operator+(const Box& b) {
          // ...
      }
};
int main() {
   Box box1;
   Box box2;
   Box3 box3 = box1 + box2;
}
#+END_SRC
* functor
Class which defines the ~operator()~. That lets you create objects which "look like" a function:
#+BEGIN_SRC cpp
// this is a functor
struct add_x {
  add_x(int val) : x(val) {}  // Constructor
  int operator()(int y) const { return x + y; }

private:
  int x;
};

int main() {
    add_x add42(42);  // create an instance of the functor class
    int i = add42(8); // 50
}
#+END_SRC
* lambda
Lambda functions are just syntactic sugar for anonymous functors.
#+BEGIN_SRC cpp
#include <functional>
#include <iostream>

auto add = [](int x, int y) { return x + y; };

int main() {
  std::cout << add(10, 20);
  return 0;
};
#+END_SRC
~[]~ is used for capturing variables.
- [&foo] capture by reference
- [&] captures all variables used in the lambda by reference
- [=] captures all variables used in the lambda by value
- [&, foo] captures variables like with [&], but foo by value
- [=, &foo] captures variables like with [=], but foo by reference

* Pointers
*Variable* (with own memory alloc etc) with value of memory address to another variable or function. Unitialized pointer points *anywhere* in memory (dangerous).
#+BEGIN_SRC cpp
double *double_ptr {nullptr};
#+END_SRC
** Address operator (~&~)
#+BEGIN_SRC cpp
int num {10};
cout << "Address of num is: " << &num << endl; // 0x61ff1c
#+END_SRC
** Dereference operator (~*~)
#+BEGIN_SRC cpp
int num{10};
int *num_ptr{&num};
cout << "Address of num is: " << num_ptr << endl; // 0x61ff1c
cout << "Value of num is: " << *num_ptr << endl;  // 10
#+END_SRC
** Heap memory allocation (~new~)
~new~ to allocate storage in heap
#+BEGIN_SRC cpp
int *int_ptr = new int; // give me heap storage for int and stores it in ~int_ptr~
*int_ptr = 100;         // store 100 in heap address ~int_ptr~
#+END_SRC
Only way how to access that heap storage is through the ~int_ptr~. If the ~int_ptr~ is lost -> memory leak.
** Heap memory deallocation (~delete~)
Every ~new~ allocated space must be ~deleted~.
#+BEGIN_SRC cpp
int *int_ptr = new int; // give me heap storage for int and stores it in ~int_ptr~
*int_ptr = 100;         // store 100 in heap address ~int_ptr~
delete int_ptr;         // frees the allocated storage
#+END_SRC
** Heap memory allocation of chunk
#+BEGIN_SRC cpp
int *array_ptr {nullptr};
array_ptr = new int[10];
delete [] array_ptr;
#+END_SRC
** Pointer vs arrays
#+BEGIN_SRC cpp
int scores[] {100, 95, 89};
cout << scores << endl;  // 0x61ff1c
cout << *scores << endl; // 100

int *scores_ptr {scores};
cout << scores_ptr << endl;  // 0x61ff1c
cout << *scores_ptr << endl; // 100
#+eND_SRC
** Pointer notations
*** Pointer subscript notation
Basically its ~*(address + offset)~
#+BEGIN_SRC cpp
int arr[]{1, 2, 3};
int *arr_ptr = arr;
cout << "#0:" << (arr_ptr[]) << endl;
cout << "#1:" << (arr_ptr[1]) << endl;
cout << "#2:" << (arr_ptr[2]) << endl;
#+END_SRC
*** Pointer offset notation
#+BEGIN_SRC cpp
int arr[]{1, 2, 3};
int *arr_ptr = arr;
cout << "#0:" << *(arr_ptr) << endl;      // 1
cout << "#1:" << *(arr_ptr + 1) << endl;  // 2
cout << "#2:" << *(arr_ptr + 2) << endl;  // 3
#+END_SRC
** Pointer Arithmetics
*** ~++~ & ~--~
#+BEGIN_SRC cpp
int foo {10};
int *int_ptr = &foo;
int_ptr++ // next memory cell
#+END_SRC
*** ~+~ & ~-~
increment pointer by ~n * sizeof(type)~
*** ~==~ & ~!=~
~==~ if pointer points to the same address
** Pointers and ~const~
*** Pointers to constants
The data pointed to cannot be changed.
#+BEGIN_SRC cpp
int foo{10};
int bar{100};
const int *foo_ptr{&foo};
*foo_ptr = 20;  // compiler error
foo_ptr = &bar; // OK
#+END_SRC
*** Constant pointers
Pointer cannot be changed.
#+BEGIN_SRC cpp
int foo{10};
int bar{100};
int *const foo_ptr{&foo};
*foo_ptr = 20;  // OK
foo_ptr = &bar; // OK
#+END_SRC
*** Constant pointers to constant
The data pointed to cannot be changed && Pointer cannot be changed.
#+BEGIN_SRC cpp
int foo{10};
int bar{100};
const int *const foo_ptr{&foo};
*foo_ptr = 20;  // ERROR
foo_ptr = &bar; // ERROR
#+END_SRC
** Pointers as function param
#+BEGIN_SRC cpp
void foo(int *bar);

void foo(int *bar) { cout << *bar << endl; }

int main() {
  int num{10};
  foo(&num);
};
#+END_SRC
** Pointer as return value
#+BEGIN_SRC cpp
int *foo(int *bar);

int *foo(int *bar) {
  cout << *bar << endl;
  return bar;
}
#+END_SRC
** Pointer bugs
*** Uninitialized pointers
~int *int_ptr~ points anywhere!
~int *int_ptr = 100~ points anyhwere!
*** Danging pointers
Pointing to the released memory.
*** ~new~ with failure
If ~new~ fails with exception. Dereferencing ~nullptr~ causes exception.
*** ~new~ without ~delete~ (memory leak)
* References

Reference to l-value. Act as *alias* for a variable.
#+BEGIN_SRC cpp
vector<string> foo{"foo", "bar", "baz"};
for (string &str : foo) {
  cout << str; // foobarbaz
}
#+END_SRC
** Alias Detail
*** c++
#+BEGIN_SRC cpp
void foo(int &foo) { }

int main() {
  int i{10};
  int &ref = i;
  foo(ref);
};
#+END_SRC
*** asm
~$ g++ -S -O0~
#+BEGIN_SRC asm
main:
.LFB1491:
        .cfi_startproc
        pushq   %rbp
        .cfi_def_cfa_offset 16
        .cfi_offset 6, -16
        movq    %rsp, %rbp
        .cfi_def_cfa_register 6
        subq    $32, %rsp
        movq    %fs:40, %rax
        movq    %rax, -8(%rbp)
        xorl    %eax, %eax
        ;==== importatant =====
        movl    $10, -20(%rbp)   ; move value 10 to [rbp-20]
        leaq    -20(%rbp), %rax  ; load *address* of [rbp-20] to register [rax]
        movq    %rax, -16(%rbp)  ; move [rax] to [rbp-16] (main [rsp])
        movq    -16(%rbp), %rax  ; move [rbp-16] to [rax]
        movq    %rax, %rdi       ; move [rax] to [rdi] (foo stack)
        ;=====================
        call    _Z3fooRi
        movl    $0, %eax
        movq    -8(%rbp), %rdx
        xorq    %fs:40, %rdx
        je      .L4
        call    __stack_chk_fail
#+END_SRC
- ~leaq~ (Load Effective Address Quad)
- ~leaq    -20(%rbp), %rax~: loads the address of ~i~ to register ~rax~
* [[https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in][Pointer vs Reference]]
|----------------------------------+------------------------------------|
| Pointer                          | Reference                          |
|----------------------------------+------------------------------------|
| reassignable                     | not reassignable                   |
|                                  |                                    |
| variable                         | alias                              |
|                                  |                                    |
| pointers to pointers to pointers | reference to variable only         |
|                                  |                                    |
| can point to nullptr             | cannot reference nullptr           |
|                                  |                                    |
| pointer arithmetics              | no reference arithmetics           |
|                                  |                                    |
| pointer must be dereferenced     | reference must not be dereferenced |
|                                  |                                    |
| can be in array                  | cannot be in array                 |
|----------------------------------+------------------------------------|
* l-value | r-value
** l-value
- nameable
- addresable
- modifiable (if not ~const~)
#+BEGIN_SRC cpp
int x {20};  // x is l-value
string name; // name is l-value
#+END_SRC
** r-value
- not l-value
  + not nameable
  + not addresable
  + not modifiable
- literal
- tmp
#+BEGIN_SRC cpp
int x {20};     // 20 is r-value
int y = x + 100 // (x + 100) is r-value
#+END_SRC
* Classes
#+BEGIN_SRC cpp
class Foo {
public:
  int foo{10};
  void bar();

private:
  int baz{10};
};
#+END_SRC
** Access modifiers
By default all attributes and methods are ~private~.
- ~public~ (everywhere)
- ~private~ (members and friends)
- ~protected~ (children)
** Pointer to a class
#+BEGIN_SRC cpp
Foo *foo = new Foo();   // on heap
(*foo).bar();
foo->bar;               // same
delete foo;
#+END_SRC
** Outside ~class~ member/methods declarations
*** ~Foo.h~
#+BEGIN_SRC cpp
#ifndef _FOO_H_
#define _FOO_H_

#include <string>

class Foo {
private:
  int bar;

public:
  Foo();
  Foo(std::string);
  ~Foo();
  int baz(std::string);
};
#endif
#+END_SRC
- #ifndef will prevent including same =h= file with every ~#include~
- same as #pragma but not every compiler has implemented it

#+BEGIN_SRC cpp
#pragma once
#include <string>

class Foo {
private:
  int bar;

public:
  Foo::Foo(std::string) { bar = 10; }; // old (bar initialized twice)
  Foo::Foo(std::string = "baz") : bar{10} {};     // better and with default
  int baz(std::string);
};
#+END_SRC

*** ~Foo.cpp~
#+BEGIN_SRC cpp
#include "Foo"

int Foo::baz(std::string qux) { return 0; }
#+END_SRC
- #include with ~<>~ means system header files
- #include with ~""~ means project header files
*** ~main.cpp~
#+BEGIN_SRC cpp
#include "Foo.h"

int main() {
  // heap
  Foo *foo_ptr = new Foo;
  foo_ptr->baz("baz");
  delete foo_ptr;         // desctructor foo_ptr called

  // stack
  Foo foo{"bar"};
};                        // desctructor foo called
#+END_SRC
- never include =cpp= files, only =h=
** contructor
#+BEGIN_SRC cpp
Foo::Foo(std::string b = "bar") : bar{b} {};
#+END_SRC
** destructor
#+BEGIN_SRC cpp
Foo::~Foo(){...};
#+END_SRC
** copy constructor
_Best Practices:_
- class has raw pointer members
- copy constructor with ~const~ reference parameter
- use STL classes (already with copy constructors)
- avoid using raw pointer members (or use smart pointers)
- if raw pointer member than *deep* copy

#+BEGIN_SRC cpp
Foo::Foo(const Foo &source) {
    ...
}
#+END_SRC
** move constructor
Uses r-value reference (~&&~) in order to move object rather than copy it.
#+BEGIN_SRC cpp
void bar(int &baz){};

int main() {
  int foo{10};
  int &l_value_ref = foo;
  int &&r_value_ref = 10;
  int &&r_value_ref2 = foo;   // compile error

  bar(foo);
  bar(10);                    // compile error
};
#+END_SRC


* Sources
1. [[https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md][C++ Guidelines]]
2. [[https://www.cprogramming.com/c++11/c++11-lambda-closures.html][C++ Lambda details]]
