#+TITLE: C++
* Compilers
- gcc
- g++
- clang
- clang++
** How to upgrade to v7?
#+BEGIN_SRC sh
sudo add-apt-repository ppa:ubuntu-toolchain-r/test
sudo apt-get update
sudo apt-get install gcc-7 g++-7
sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-7 20 --slave /usr/bin/g++ g++ /usr/bin/g++-7
#+END_SRC
** How to compile with asm output?
#+BEGIN_SRC sh
g++ -S <file.cpp>
#+END_SRC
** How to get readable asm output?
#+BEGIN_SRC sh
g++ -O0 -S main.cpp
# +END_SRC
or
,#+BEGIN_SRC sh
g++ -g -c main.cpp && objdump -d -M intel -S main.o
#+END_SRC
* Namespaces
#+BEGIN_SRC cpp
#include <iostream>
int main() {
  std::cout << "Foo";
}
#+END_SRC
or
#+BEGIN_SRC cpp
#include <iostream>
using namespace std;
int main() {
  cout << "Foo";
}
#+END_SRC
or
#+BEGIN_SRC cpp
#include <iostream>
using std::cout;
int main() {
  cout << "Foo";
}
#+END_SRC
* ~cout~
Console output stream.
#+BEGIN_SRC cpp
cout << "foo"; // insertion operator
#+END_SRC
* ~cin~
Console input stream.
#+BEGIN_SRC cpp
string foo;
cin >> foo; // extraction operator
#+END_SRC
* Variable Initializations
#+BEGIN_SRC cpp
int i = 20; // asignement
int i (20); // constructor
int i {20}; // initialization
#+END_SRC
* Primitive Types
|------------------------+-------------------+---------------------------------|
| Type                   | Typical Bit Width | Typical Range                   |
|------------------------+-------------------+---------------------------------|
| char                   | 1byte             | -127 to 127 or 0 to 255         |
| unsigned char          | 1byte             | 0 to 255                        |
| signed char            | 1byte             | -127 to 127                     |
| int                    | 4bytes            | -2147483648 to 2147483647       |
| unsigned int           | 4bytes            | 0 to 4294967295                 |
| signed int             | 4bytes            | -2147483648 to 2147483647       |
| short int              | 2bytes            | -32768 to 32767                 |
| unsigned short int     | 2bytes            | 0 to 65,535                     |
| signed short int       | 2bytes            | -32768 to 32767                 |
| long int               | 8bytes            | -2,147,483,648 to 2,147,483,647 |
| signed long int        | 8bytes            | same as long int                |
| unsigned long int      | 8bytes            | 0 to 4,294,967,295              |
| long long int          | 8bytes            | -(2^63) to (2^63)-1             |
| unsigned long long int | 8bytes            | 0 to 18,446,744,073,709,551,615 |
| float                  | 4bytes            |                                 |
| double                 | 8bytes            |                                 |
| long double            | 12bytes           |                                 |
| wchar_t                | 2 or 4 bytes      | 1 wide character                |
| bool                   | 1byte             | false/true                      |
|------------------------+-------------------+---------------------------------|
* Primitive Type Alias
#+BEGIN_SRC cpp
typedef int feet;
feet distance {0};
#+END_SRC
* ~enum~
#+BEGIN_SRC cpp
enum color { red, green, blue } c;
c = blue;
#+END_SRC
* ~bool~
~false~ is 0
~true~ is everything except 0
#+BEGIN_SRC cpp
cout << 2 + 2 == 5;    // 0
cout << std::boolalpha;
cout << 2 + 2 == 5;    // false
#+END_SRC
* ~std::sizeof~
#+BEGIN_SRC cpp
sizeof(char);  // 1 bytes
#+END_SRC
* ~climits~ and ~cfloats~
#+BEGIN_SRC cpp
#+BEGIN_SRC cpp
climits::CHAR_MAX; // 127
#+END_SRC
* Constants
- literal                        // x = 12
- declared (~const~)             // const pi {3.1415}
- expression (~constexpr~)       // constexpr int factorial(int n) {...}
- enumerated (~enum~)            // enum foo {bar} f;
- defined (~#define~)            // #define pi 3.14
* Arrays
Just an address of the first element of the chunk of memory.
#+BEGIN_SRC cpp
int foo [3];           // sized array of 3
int foo [] {1, 2, 3};  // automatically sized array
int foo [3] {0};       // sized and init all to 0
int foo [3] {};        // same as {0}
foo[0] = 20;           // assignment
foo[0];                // reading
int foo [3][4] {}      // 2 dim
int foo [3][4] {
    {1,2,3,4},
    {},
    {},
};
#+END_SRC
* ~std::vector~
#+BEGIN_SRC cpp
std::vector <char> vowels;
std::vector <char> vowels (5);                         // sized 5
std::vector <char> vowels (5, 'a');                    // sized 5 and initialized all to 'a'
std::vector <char> vowels {'a', 'e', 'i', 'o', 'u'};   // sized 5 and initialized
std::vector <vector<char>>;                            // 2 dim vector
vowels[0];
vowels.at(0);                                          // same
vowels.at(2) = 'i';
#+END_SRC
* ~static_cast~
#+BEGIN_SRC cpp
static_cast<double>(12);
(double) 12;             // obsolete
#+END_SRC
* Operator Precedence
|-------------------+-----------------------------------------------------------+-------------------------------------------------+---------------|
| Precedence        | Operator                                                  | Description                                     | Associativity |
|-------------------+-----------------------------------------------------------+-------------------------------------------------+---------------|
| 1                 | ::                                                        | Scope resolution                                | Left-to-right |
| 2                 | a++   a--                                                 | Suffix/postfix increment and decrement          |               |
| type()   type{}   | Functional cast                                           |                                                 |               |
| a()               | Function call                                             |                                                 |               |
| a[]               | Subscript                                                 |                                                 |               |
| .   ->            | Member access                                             |                                                 |               |
| 3                 | ++a   --a                                                 | Prefix increment and decrement                  | Right-to-left |
| +a   -a           | Unary plus and minus                                      |                                                 |               |
| !   ~             | Logical NOT and bitwise NOT                               |                                                 |               |
| (type)            | C-style cast                                              |                                                 |               |
| *a                | Indirection (dereference)                                 |                                                 |               |
| &a                | Address-of                                                |                                                 |               |
| sizeof            | Size-of[note 1]                                           |                                                 |               |
| co_await          | await-expression (C++20)                                  |                                                 |               |
| new   new[]       | Dynamic memory allocation                                 |                                                 |               |
| delete   delete[] | Dynamic memory deallocation                               |                                                 |               |
| 4                 | .*   ->*                                                  | Pointer-to-member                               | Left-to-right |
| 5                 | a*b   a/b   a%b                                           | Multiplication, division, and remainder         |               |
| 6                 | a+b   a-b                                                 | Addition and subtraction                        |               |
| 7                 | <<   >>                                                   | Bitwise left shift and right shift              |               |
| 8                 | <=>                                                       | Three-way comparison operator (since C++20)     |               |
| 9                 | <   <=                                                    | For relational operators < and ≤ respectively   |               |
| >   >=            | For relational operators > and ≥ respectively             |                                                 |               |
| 10                | ==   !=                                                   | For relational operators = and ≠ respectively   |               |
| 11                | &                                                         | Bitwise AND                                     |               |
| 12                | ^                                                         | Bitwise XOR (exclusive or)                      |               |
| 13                | \vert                                                     | Bitwise OR (inclusive or)                       |               |
| 14                | &&                                                        | Logical AND                                     |               |
| 15                | \vert\vert                                                |                                                 | Logical OR    |
| 16                | a?b:c                                                     | Ternary conditional[note 2]                     | Right-to-left |
| throw             | throw operator                                            |                                                 |               |
| co_yield          | yield-expression (C++20)                                  |                                                 |               |
| =                 | Direct assignment (provided by default for C++ classes)   |                                                 |               |
| +=   -=           | Compound assignment by sum and difference                 |                                                 |               |
| *=   /=   %=      | Compound assignment by product, quotient, and remainder   |                                                 |               |
| <<=   >>=         | Compound assignment by bitwise left shift and right shift |                                                 |               |
| &=   ^=           | =                                                         | Compound assignment by bitwise AND, XOR, and OR |               |
| 17                | ,                                                         | Comma                                           | Left-to-right |
|-------------------+-----------------------------------------------------------+-------------------------------------------------+---------------|
* ~auto~
Type inference keyword.
#+BEGIN_SRC cpp
// variables
auto d{ 5.0 };            // double

// functions
auto add(int x, int y) {
    return x + y;         // int
}

// function parameters (C++20)
void addAndPrint(auto x, auto y) {
    std::cout << x + y;
}
#+END_SRC
* Strings
- C style
- C++ style
** C style (array of chars)
- array of characters
- terminated by null character (character with value 0)
- libs: ~[[http://www.cplusplus.com/reference/cstring/][<cstring>]]~ and ~[[http://www.cplusplus.com/reference/cstdlib/][<cstdlib>]]~

#+BEGIN_SRC cpp
char foo [8] {"foo"};   // literal
cout << std::strlen(foo);  // (f | o | o | 0) = 3
#+END_SRC
** C++ style (string object)
#+BEGIN_SRC cpp
#include <string>
using namespace std
string s1;
string s2 {"Frank"};
string s3 {s2};
string s4 {"Frank", 3} // Fra
string s5 {s3, 0, 2}   // Fr
string s6 (3, 'X');    // XXX
#+END_SRC
* ~std::size_t~
- return type of ~sizeof~
- unsigned integer with enough bytes to represent the size of any type
- anything that you need to compare in the loop condition against something that is naturally a ~std::size_t~ itself.
  #+BEGIN_SRC cpp
  for (std::size_t i = 0; i < 10; ++i) {
      // ...
  }
  #+END_SRC
* Function Prototypes
- Way to tell compiler about used functions.
  #+BEGIN_SRC cpp
  int foo(int);
  int foo(int a); // same
  #+END_SRC
* Pass-by-value by default
Function arguments are copies by default. Even for objects (shallow copy).
#+BEGIN_SRC cpp
void change_by_value(string s) { s = "changed"; }
void change_by_ref(string &s) { s = "changed"; }

int main() {
  string s = "original";

  change_by_value(s);
  cout << s << endl; // original

  change_by_ref(s);
  cout << s << endl; // changed
}
#+END_SRC
* Pass-by-reference
Formal parameter will be an alias for the actual parameter.
#+BEGIN_SRC cpp
void foo(int &a, int &b);
#+END_SRC
* Default arguments
Must be tail of the function arguments.
#+BEGIN_SRC cpp
void foo(int bar, int baz = 10);
#+END_SRC
* Function static variable
Variable bound to a function declaration.
#+BEGIN_SRC cpp
void foo() {
    static int bar = 5000;
}
#+END_SRC
* Function overloading
Overloaded function must have different parameters (amount or type). Return value is not considered.
#+BEGIN_SRC cpp
void foo(int bar);
void foo(double baz);
int foo(double baz);  // error
#+END_SRC
* Function stack
|-----------|
| Heap      |
| Stack     |
| Registers |
| Opcodes   |
|-----------|
** c++
#+BEGIN_SRC cpp
int foo(int x, int y) {
  int a = 0;
  int b = x;
  int c = y;
  return 22;
}

int main() { int bar = foo(10, 20); }
#+END_SRC
** assembly
~$ g++ -O0 -S main.cpp~
#+BEGIN_SRC asm
        .file   "main.cpp"
        .text
        .globl  _Z3fooii
        .type   _Z3fooii, @function
_Z3fooii:
.LFB0:
        ;; prologue
        .cfi_startproc
        pushq   %rbp
        .cfi_def_cfa_offset 16
        .cfi_offset 6, -16
        movq    %rsp, %rbp
        ;; main stack frame
        .cfi_def_cfa_register 6
        movl    %edi, -20(%rbp)
        movl    %esi, -24(%rbp)
        movl    $0, -12(%rbp)
        movl    -20(%rbp), %eax
        movl    %eax, -8(%rbp)
        movl    -24(%rbp), %eax
        movl    %eax, -4(%rbp)
        movl    $22, %eax
        ;; epilogue
        popq    %rbp
        .cfi_def_cfa 7, 8
        ret
        .cfi_endproc
.LFE0:
        .size   _Z3fooii, .-_Z3fooii
        .globl  main
        .type   main, @function
main:
.LFB1:
        ;; prologue
        .cfi_startproc
        pushq   %rbp
        .cfi_def_cfa_offset 16
        .cfi_offset 6, -16
        ;; main
        movq    %rsp, %rbp
        .cfi_def_cfa_register 6
        movl    $20, %esi
        movl    $10, %edi
        call    _Z3fooii
        movl    $0, %eax
        ;; epilogue
        popq    %rbp
        .cfi_def_cfa 7, 8
        ret
        .cfi_endproc
.LFE1:
        .size   main, .-main
        .ident  "GCC: (Ubuntu 7.5.0-3ubuntu1~16.04) 7.5.0"
        .section        .note.GNU-stack,"",@progbits
#+END_SRC
- ~call~ instruction pushes the current instruction pointer onto the stack and then jumps to the address provided in its argument
 - ~cfi_def_cfa_offset~ (CFA) is defined to be the value of the stack pointer at the call site in the previous frame
- Heap runs in the same memory space as the stack, just on the other end of memory.
- There is absolutely no difference between data in the heap and the stack, except for its location in the memory space.

** table
|----+----------+------------------------------------------+----------------|
|    | [ebp]    | pushq   %rbp                             |                |
|----+----------+------------------------------------------+----------------|
| 20 | [ebp-4]  | movl    -24(%rbp), %eax                  | c              |
|    |          | movl    %eax, -4(%rbp)                   |                |
|    |          |                                          |                |
| 10 | [ebp-8]  | movl    -20(%rbp), %eax                  | b              |
|    |          | movl    %eax, -8(%rbp)                   |                |
|    |          |                                          |                |
|  0 | [ebp-12] | movl   $0, -12(%rbp)                     | a              |
|    |          |                                          |                |
|----+----------+------------------------------------------+----------------|
|    | [esp]    | sub    rsp,0x10 / .cfi_def_cfa_offset 16 |                |
|    | [ebp]    | movq    %rsp, %rbp                       |                |
|----+----------+------------------------------------------+----------------|
| rT | [ebp-16] | call    _Z3fooii                         | return address |
|    |          |                                          |                |
| 10 | [ebp-20] | movl    $10, %edi                        | argument#1     |
|    |          | movl    %edi, -20(%rbp)                  |                |
|    |          |                                          |                |
| 20 | [ebp-24] | movl    $20, %esi                        | argument#2     |
|    |          | movl    %esi, -24(%rbp)                  |                |
|----+----------+------------------------------------------+----------------|
* Operator Overload
#+bEGIN_SRC cpp
class Box {
   public:
      // Overload + operator to add two Box objects.
      Box operator+(const Box& b) {
          // ...
      }
};
int main() {
   Box box1;
   Box box2;
   Box3 box3 = box1 + box2;
}
#+END_SRC
* functor
Class which defines the ~operator()~. That lets you create objects which "look like" a function:
#+BEGIN_SRC cpp
// this is a functor
struct add_x {
  add_x(int val) : x(val) {}  // Constructor
  int operator()(int y) const { return x + y; }

private:
  int x;
};

int main() {
    add_x add42(42);  // create an instance of the functor class
    int i = add42(8); // 50
}
#+END_SRC
* lambda
Lambda functions are just syntactic sugar for anonymous functors.
#+BEGIN_SRC cpp
#include <functional>
#include <iostream>

auto add = [](int x, int y) { return x + y; };

int main() {
  std::cout << add(10, 20);
  return 0;
};
#+END_SRC
~[]~ is used for capturing variables.
- [&foo] capture by reference
- [&] captures all variables used in the lambda by reference
- [=] captures all variables used in the lambda by value
- [&, foo] captures variables like with [&], but foo by value
- [=, &foo] captures variables like with [=], but foo by reference

* Pointers
*Variable* (with own memory alloc etc) with value of memory address to another variable or function. Unitialized pointer points *anywhere* in memory (dangerous).
#+BEGIN_SRC cpp
double *double_ptr {nullptr};
#+END_SRC
** Address operator (~&~)
#+BEGIN_SRC cpp
int num {10};
cout << "Address of num is: " << &num << endl; // 0x61ff1c
#+END_SRC
** Dereference operator (~*~)
#+BEGIN_SRC cpp
int num{10};
int *num_ptr{&num};
cout << "Address of num is: " << num_ptr << endl; // 0x61ff1c
cout << "Value of num is: " << *num_ptr << endl;  // 10
#+END_SRC
** Heap memory allocation (~new~)
~new~ to allocate storage in heap
#+BEGIN_SRC cpp
int *int_ptr = new int; // give me heap storage for int and stores it in ~int_ptr~
*int_ptr = 100;         // store 100 in heap address ~int_ptr~
#+END_SRC
Only way how to access that heap storage is through the ~int_ptr~. If the ~int_ptr~ is lost -> memory leak.
** Heap memory deallocation (~delete~)
Every ~new~ allocated space must be ~deleted~.
#+BEGIN_SRC cpp
int *int_ptr = new int; // give me heap storage for int and stores it in ~int_ptr~
*int_ptr = 100;         // store 100 in heap address ~int_ptr~
delete int_ptr;         // frees the allocated storage
#+END_SRC
** Heap memory allocation of chunk
#+BEGIN_SRC cpp
int *array_ptr {nullptr};
array_ptr = new int[10];
delete [] array_ptr;
#+END_SRC
** Pointer vs arrays
#+BEGIN_SRC cpp
int scores[] {100, 95, 89};
cout << scores << endl;  // 0x61ff1c
cout << *scores << endl; // 100

int *scores_ptr {scores};
cout << scores_ptr << endl;  // 0x61ff1c
cout << *scores_ptr << endl; // 100
#+eND_SRC
** Pointer notations
*** Pointer subscript notation
Basically its ~*(address + offset)~
#+BEGIN_SRC cpp
int arr[]{1, 2, 3};
int *arr_ptr = arr;
cout << "#0:" << (arr_ptr[]) << endl;
cout << "#1:" << (arr_ptr[1]) << endl;
cout << "#2:" << (arr_ptr[2]) << endl;
#+END_SRC
*** Pointer offset notation
#+BEGIN_SRC cpp
int arr[]{1, 2, 3};
int *arr_ptr = arr;
cout << "#0:" << *(arr_ptr) << endl;      // 1
cout << "#1:" << *(arr_ptr + 1) << endl;  // 2
cout << "#2:" << *(arr_ptr + 2) << endl;  // 3
#+END_SRC
** Pointer Arithmetics
*** ~++~ & ~--~
#+BEGIN_SRC cpp
int foo {10};
int *int_ptr = &foo;
int_ptr++ // next memory cell
#+END_SRC
*** ~+~ & ~-~
increment pointer by ~n * sizeof(type)~
*** ~==~ & ~!=~
~==~ if pointer points to the same address
** Pointers and ~const~
*** Pointers to constants
The data pointed to cannot be changed.
#+BEGIN_SRC cpp
int foo{10};
int bar{100};
const int *foo_ptr{&foo};
*foo_ptr = 20;  // compiler error
foo_ptr = &bar; // OK
#+END_SRC
*** Constant pointers
Pointer cannot be changed.
#+BEGIN_SRC cpp
int foo{10};
int bar{100};
int *const foo_ptr{&foo};
*foo_ptr = 20;  // OK
foo_ptr = &bar; // OK
#+END_SRC
*** Constant pointers to constant
The data pointed to cannot be changed && Pointer cannot be changed.
#+BEGIN_SRC cpp
int foo{10};
int bar{100};
const int *const foo_ptr{&foo};
*foo_ptr = 20;  // ERROR
foo_ptr = &bar; // ERROR
#+END_SRC
** Pointers as function param
#+BEGIN_SRC cpp
void foo(int *bar);

void foo(int *bar) { cout << *bar << endl; }

int main() {
  int num{10};
  foo(&num);
};
#+END_SRC
** Pointer as return value
#+BEGIN_SRC cpp
int *foo(int *bar);

int *foo(int *bar) {
  cout << *bar << endl;
  return bar;
}
#+END_SRC
** Pointer bugs
*** Uninitialized pointers
~int *int_ptr~ points anywhere!
~int *int_ptr = 100~ points anyhwere!
*** Danging pointers
Pointing to the released memory.
*** ~new~ with failure
If ~new~ fails with exception. Dereferencing ~nullptr~ causes exception.
*** ~new~ without ~delete~ (memory leak)
* References

Reference to l-value. Act as *alias* for a variable.
#+BEGIN_SRC cpp
vector<string> foo{"foo", "bar", "baz"};
for (string &str : foo) {
  cout << str; // foobarbaz
}
#+END_SRC
** Alias Detail
*** c++
#+BEGIN_SRC cpp
void foo(int &foo) { }

int main() {
  int i{10};
  int &ref = i;
  foo(ref);
};
#+END_SRC
*** asm
~$ g++ -S -O0~
#+BEGIN_SRC asm
main:
.LFB1491:
        .cfi_startproc
        pushq   %rbp
        .cfi_def_cfa_offset 16
        .cfi_offset 6, -16
        movq    %rsp, %rbp
        .cfi_def_cfa_register 6
        subq    $32, %rsp
        movq    %fs:40, %rax
        movq    %rax, -8(%rbp)
        xorl    %eax, %eax
        ;==== importatant =====
        movl    $10, -20(%rbp)   ; move value 10 to [rbp-20]
        leaq    -20(%rbp), %rax  ; load *address* of [rbp-20] to register [rax]
        movq    %rax, -16(%rbp)  ; move [rax] to [rbp-16] (main [rsp])
        movq    -16(%rbp), %rax  ; move [rbp-16] to [rax]
        movq    %rax, %rdi       ; move [rax] to [rdi] (foo stack)
        ;=====================
        call    _Z3fooRi
        movl    $0, %eax
        movq    -8(%rbp), %rdx
        xorq    %fs:40, %rdx
        je      .L4
        call    __stack_chk_fail
#+END_SRC
- ~leaq~ (Load Effective Address Quad)
- ~leaq    -20(%rbp), %rax~: loads the address of ~i~ to register ~rax~
* [[https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in][Pointer vs Reference]]
|----------------------------------+------------------------------------|
| Pointer                          | Reference                          |
|----------------------------------+------------------------------------|
| reassignable                     | not reassignable                   |
|                                  |                                    |
| variable                         | alias                              |
|                                  |                                    |
| pointers to pointers to pointers | reference to variable only         |
|                                  |                                    |
| can point to nullptr             | cannot reference nullptr           |
|                                  |                                    |
| pointer arithmetics              | no reference arithmetics           |
|                                  |                                    |
| pointer must be dereferenced     | reference must not be dereferenced |
|                                  |                                    |
| can be in array                  | cannot be in array                 |
|----------------------------------+------------------------------------|
* l-value | r-value
** l-value
- nameable
- addresable
- modifiable (if not ~const~)
#+BEGIN_SRC cpp
int x {20};  // x is l-value
string name; // name is l-value
#+END_SRC
** r-value
- not l-value
  + not nameable
  + not addresable
  + not modifiable
- literal
- tmp
#+BEGIN_SRC cpp
int x {20};     // 20 is r-value
int y = x + 100 // (x + 100) is r-value
#+END_SRC
* OO
** ~class~
#+BEGIN_SRC cpp
class Foo {
public:
  int foo{10};
  void bar();

private:
  int baz{10};
};
#+END_SRC
** Access modifiers
By default all attributes and methods are ~private~.
- ~public~ (everywhere)
- ~private~ (members and friends)
- ~protected~ (children)
** Pointer to a class
#+BEGIN_SRC cpp
Foo *foo = new Foo();   // on heap
(*foo).bar();
foo->bar;               // same
delete foo;
#+END_SRC
** Outside ~class~ member/methods declarations
*** ~Foo.h~
#+BEGIN_SRC cpp
#ifndef _FOO_H_
#define _FOO_H_

#include <string>

class Foo {
private:
  int bar;

public:
  Foo();
  Foo(std::string);
  ~Foo();
  int baz(std::string);
};
#endif
#+END_SRC
- #ifndef will prevent including same =h= file with every ~#include~
- same as #pragma but not every compiler has implemented it

#+BEGIN_SRC cpp
#pragma once
#include <string>

class Foo {
private:
  int bar;

public:
  Foo::Foo(std::string) { bar = 10; }; // old (bar initialized twice)
  Foo::Foo(std::string = "baz") : bar{10} {};     // better and with default
  int baz(std::string);
};
#+END_SRC

*** ~Foo.cpp~
#+BEGIN_SRC cpp
#include "Foo"

int Foo::baz(std::string qux) { return 0; }
#+END_SRC
- #include with ~<>~ means system header files
- #include with ~""~ means project header files
*** ~main.cpp~
#+BEGIN_SRC cpp
#include "Foo.h"

int main() {
  // heap
  Foo *foo_ptr = new Foo;
  foo_ptr->baz("baz");
  delete foo_ptr;         // desctructor foo_ptr called

  // stack
  Foo foo{"bar"};
};                        // desctructor foo called
#+END_SRC
- never include =cpp= files, only =h=
** contructor
#+BEGIN_SRC cpp
Foo::Foo(std::string b = "bar") : bar{b} {};
#+END_SRC
** destructor
#+BEGIN_SRC cpp
Foo::~Foo(){...};
#+END_SRC
** copy constructor
_Best Practices:_
- class has raw pointer members
- copy constructor with ~const~ reference parameter
- use STL classes (already with copy constructors)
- avoid using raw pointer members (or use smart pointers)
- if raw pointer member than *deep* copy

#+BEGIN_SRC cpp
Foo::Foo(const Foo &source) {
    ...
}
#+END_SRC
** move constructor
Uses r-value reference (~&&~) in order to move object rather than copy them.
*Steal the data and then null out the source pointer.*
#+BEGIN_SRC cpp
class Bar {
private:
  int *data; // raw pointer
public:
  Bar(Bar &&source);
};
Bar::Bar(Bar &&source) : data{source.data} {};

void bar(int &baz){};

int main() {
  int foo{10};
  int &l_value_ref = foo;
  int &&r_value_ref = 10;
  int &&r_value_ref2 = foo;   // compile error

  bar(foo);
  bar(10);                    // compile error

  vector<Move> vec;
  vec.push_back(Bar{});       // move constructor called, no copy
};
#+END_SRC
** default constructor
Implicit or explicit.
#+BEGIN_SRC cpp
class Foo {
  Foo() = default;
};
#+END_SRC
** delete constructor
Removes default (implicit) constructor.
#+BEGIN_SRC cpp
class Foo {
  Foo() = delete;
};
#+END_SRC
** ~this~ pointer
#+BEGIN_SRC cpp
class Foo {
    int bar;
    void set_bar(int bar) {
        this->bar = bar;
    }
}
#+END_SRC
** ~const~ methods
~get_name()~ can't change anything from Foo. Also can be called from ~const Foo~.
#+BEGIN_SRC cpp
class Foo {
public:
   string get_name() const;
}
#+END_SRC
** ~static~ members
#+BEGIN_SRC cpp
class Bar {
public:
  static int baz;
  static void get_baz();
};

int Bar::baz = 10;
void Bar::get_baz(){};
#+END_SRC
** ~struct~
Same as ~class~ but every member is public by default.
** ~friend~
Access to a private members of a ~class~ outside of a ~class~ declaration.
- granted *NOT* taken
- not symmetric (A friendof B, B !friendof A)
- not transitive (A friendof B, B friendof C, C !friendof A)
#+BEGIN_SRC cpp
class Foo {
public:
  void change_bar(Bar bar) { bar.baz = 20; }
};

class Bar {
private:
  int baz;
  friend class Foo; // Foo has now access to all members of Bar

public:
  friend void Foo::change_bar(int i);
};
#+END_SRC
** Inheritance
#+BEGIN_SRC cpp
class Foo: public Bar {
  int:
    double double_value;
  public:
    Foo(): Bar{}, double_value{0} {}
  // derived code
}
#+END_SRC
- _public inheritance_: derived members has same access modifiers as base class members.
- _protected inheritance_: derived members (~public~ and ~protected~) has ~protected~ access modifier.
- _private inheritance_: derived member has ~private~ access.
** Static Binding (compile time, by default)
- Static binding (performance reasons)
#+BEGIN_SRC cpp
class Base {
public:
  void foo();
}
Base *ptr = new Derived();
ptr->foo(); // !!! Base called, not Derived !!!
#+END_SRC
** Dynamic Binding (in runtime)
- Dynamic binding.
#+BEGIN_SRC cpp
class Base {
public:
  virtual void foo();
}
Base *ptr = new Derived();
ptr->foo(); // !!! Derived called !!!
#+END_SRC
*IMPORTANT*: if ~class~ contains ~virtual~ members, ~virtual~ destructor must be provided
#+BEGIN_SRC cpp
class Base {
  public:
    virtual ~Base();
}
#+END_SRC
** ~override~
Use in order to throw compile time error when function signature is different.
#+BEGIN_SRC cpp
class Derived: public Base {
public:
  virtual void foo() override {}
}
** Abstract ~class~
Is one with at least one pure virtual function.
** Pure virtual functions
#+BEGIN_SRC cpp
virtual void foo() = 0;
#+END_SRC
** Interface
Interface is ~class~ with only pure virtual functions.

* ~constexpr~
Ensures to be initialized at compile time.
* ~const~
Part of data type. Constraits about object immutability.
* ~constexpr const~
Ensures to be initialized at compile time and be immutable.
* ~final~
Can't be overwritten.
#+BEGIN_SRC cpp
class Foo final {}
#+END_SRC
* Resource Acquisition Is Initialization (RAII)
 Paradigm which states that you should acquire resources when you are at the initialisation phase of an object's lifetime.
- Resource Asquisition: open file/alloc memory/lock...
- Is Initialization   : constructor
* SmartPointers

Wrapper around raw pointers. Points to the heap and are alloc/dealloc automatically when not needed.
- ~unique_ptr~
- ~shared_ptr~
- ~weak_ptr~
** ~unique_ptr~
Unique ownership of heap object (one owner). Cannot by reassigned or copied. *Can* be moved.
#+BEGIN_SRC cpp
void foo(unique_ptr<int>){};

int main() {
  unique_ptr<int> p1{new int{100}};

  cout << p1.get() << endl; // memory address
  cout << *p1 << endl;      // 100
  // p1.reset();            // p1 is now nullptr
  if (p1) { // checks if p1 is initialized
  }

  // foo(p1); // compile error
  foo(std::move(p1));

  cout << *p1 << endl; // runtime error - p1 moved
};                                // p1 automatically deleted
#+END_SRC

*** ~std::move()~
Moves *ownership* of the pointer. Original pointer is set to ~nullptr~.
#+BEGIN_SRC cpp
foo(std::move(p1));
#+END_SRC

*** ~make_unique<type>(constructor)~ (C++14)
- more efficient - no ~new~ or ~delete~ calls
#+BEGIN_SRC cpp
unique_ptr<int> p1 = make_unique<int>(100);
auto p2 = make_unique<int>(100);             // same
#+END_SRC
** ~shared_ptr~
Shared ownership of heap objects (multiple owners). When the ~use_count~ becomes 0 the heap object is deallocated (~delete~).
#+BEGIN_SRC cpp
void foo(shared_ptr<int> p1) {
  cout << p1.use_count() << endl; // 2
};

int main() {
  shared_ptr<int> p1{new int{100}};

  cout << p1.get() << endl; // memory address
  cout << *p1 << endl;      // 100
  // p1.reset();            // p1 is now nullptr
  if (p1) { // checks if p1 is initialized
  }

  foo(p1);                        // compile error
  cout << p1.use_count() << endl; // 1
  foo(p1);
  cout << p1.use_count() << endl; // 1
  p1.reset();
  cout << p1.use_count() << endl; // 0
};                                // p1 automatically deleted
#+END_SRC
*** ~make_shared<type>(constructor)~
- more efficient - no ~new~ or ~delete~ calls
#+BEGIN_SRC cpp
unique_ptr<int> p1 = make_shared<int>(100);
auto p2 = make_shared<int>(100);             // same
#+END_SRC
** ~weak_ptr~
No ownership. Created from ~shared_ptr~. Used mainly when circular dependency.

*** Problem
#+BEGIN_SRC plantuml
@startuml
A -> B: shared_ptr
B -> A: shared_ptr
@enduml
#+END_SRC

#+RESULTS:
[[file:/tmp/babel-vNLoK3/plantuml-aGEwnp.png]]
- A keeps B alive and vice versa. When A goes out of scope then ~delete~ is called but only after ~use_count~ is not 0. That never happens because B keeps alive A and vice versa.
*** Solution
#+BEGIN_SRC plantuml
@startuml
A -> B: shared_ptr
B -> A: weak_ptr
@enduml
#+END_SRC

#+RESULTS:
[[file:/tmp/babel-vNLoK3/plantuml-sEr1d5.png]]

By using a ~weak_ptr~, you can create a ~shared_ptr~ that joins to an existing set of related instances, but only if the underlying memory resource is still valid. A ~weak_ptr~ itself does not participate in the reference counting, and therefore, it cannot prevent the reference count from going to zero. However, you can use a ~weak_ptr~ to try to obtain a new copy of the ~shared_ptr~ with which it was initialized. If the memory has already been deleted, the ~weak_ptr~'s bool operator returns false. If the memory is still valid, the new shared pointer increments the reference count and guarantees that the memory will be valid as long as the ~shared_ptr~ variable stays in scope.
** Golden cascade
Use ~unique_ptr~ as much as possible. Then ~shared_ptr~, then ~weak_ptr~.
** custom deleter
#+BEGIN_SRC cpp
std::smart_pointer ptr {new Some_Class(), custom_delete_fn};
#+END_SRC
* Exceptions
If an exception is thrown but not caught in the current scope, C++ tries to find a handler for the exception by /unwinding the stack/. If no handler is found then application is terminated. If found then app continues in that stack (unwinded stack). If there is ~delete~ after unhandled exception -> memory leak.

#+BEGIN_SRC cpp
int main() {
    try {
        throw 0;    // everything can be thrown
        // code
    } catch(int &ex) {
        // handling
    } catch (std::string &ex) {
        // handling
    } catch(...) {
        // default handling
    }
}
#+END_SRC
*** Custom exception
#+BEGIN_SRC cpp
class FooException : std::exception {
public:
  virtual const char *what() const noexcept { return "Foooo"; }
};

...
try {
    ...
} catch (FooException &ex) {
    cout << ex.what << endl;
}
#+END_SRC

** ~noexcept~
Keyword that indicates, that method or constructor will not thrown an exception.
#+BEGIN_SRC cpp
class Foo {
    Foo() noexcept {
        ...
    }
};

#+END_SRC
* TODO IO
* TODO Streams
* Macros
#+BEGIN_SRC cpp
#define MAX_SIZE 100      // removed
cout << MAX_SIZE << endl; // replaced with 100
#+END_SRC
* Templates
Way of creating generic functions and classes. Specific implementations are created by compiler at compile time.
- Function Templates
- Class Templates
** Function Templates
#+BEGIN_SRC cpp
// template <class T>      // same as typename
template <typename T>
T foo(T a, T b) {};
// is only bluprint and will not generate the code at compile time

std::cout << foo<int>(10, 20); // now is generated foo with int params at compile time
#+END_SRC
** Class Templates
#+BEGIN_SRC cpp
template <typename T>
class Foo {
public:
  T bar;
};
Foo<int> foo {};
#+END_SRC
** Variable Templates
#+BEGIN_SRC cpp
template<typename T> constexpr T pi = T(3.141592653589793238462643383L);
#+END_SRC

** Template Value Parameter
~template~ can be with value and not a type.
#+BEGIN_SRC cpp
template <int N> int add2() { return 2 + N; };
cout << add2<10>() << endl; // 12
#+END_SRC
** Template specialization
First template will be used *unless* ~T~ will be ~char~. Then second one will be used.
#+BEGIN_SRC cpp
template <class T> class mycontainer { ... };
template <> class mycontainer <char> { ... };
#+END_SRC

* Rule of Three
If a class defines any of the following then it should probably explicitly define all three:
- destructor
- copy constructor
- copy assignment operator
 
** Reason
In order to have a need for destructor/copy constructor/copy assignment operator, object must manage a pointer or non-sharable reference. If you write a class without unmanaged resources, there is no need to declare any of the five special member functions yourself, and you will get correct copy semantics and move semantics for free. Why? Because implicit implementation of these functions is using shallow copy and then every copy would share its resources.
** Example
#+BEGIN_SRC cpp
#include <iostream>

class Array {
 public:
  explicit Array(int size) : size(size), data(new int[size]) {}

  ~Array() {
    if (data != nullptr) {
      delete[] data;
    }
  }

  int size;
  int* data;
};

int main() {
  Array first(20);
  first.data[0] = 25;

  {
    Array copy = first;
    std::cout << first.data[0] << " " << copy.data[0] << std::endl;
  }  // (1)

  first.data[0] = 10;  // (2)
}
#+END_SRC

RESULTS:
25 25
Segmentation fault // !!!

In order to fix this we need destructor (to free memory), custom copy constructor (to do deep copy instead of shallow) and copy assignment operator (because it is used instead of copy when ~=~).

* Rule of Five
Expand of /Rule of Three/ for performance reasons:
- move constructor
- move assignment operator
** Reason
Performance. We can "steal" data from /rvalue/ using move constructor instead of the expensive deep copy using copy constructor. It is safe to steal it from the /rvalue/ because it will be deleted anyway.
** Example
#+BEGIN_SRC cpp
string(string&& that)   // string&& is an rvalue reference to a string
{
    data = that.data;
    that.data = nullptr;
}

string a(x);                                    // COPY (deep copy)
string b(x + y);                                // MOVE (steal)
string c(some_function_returning_a_string());   // MOVE (steal)
#+END_SRC

* Rule of 4,5
Copy assignment and move assignment functions can be replaced with one assignment by value function.
#+BEGIN_SRC cpp
rule_of_five& operator=(rule_of_five other) noexcept
{
    std::swap(cstring, other.cstring);
    return *this;
}
#+END_SRC
** Reason
RVO optimalisation by compiler. If called with /lvalue/ then copy is made either way, if with /rvalue/ then compiler will create memory from caller in its stack to save value from callee there. More info [[https://web.archive.org/web/20140113221447/http://cpp-next.com/archive/2009/08/want-speed-pass-by-value/][here]].

* Rule of Zero
Classes without resource *should not* have custom destructors, copy/move constructors or copy/move assignment operators. If base class will be use for polymorphism, then should use ~public virtual~ destructor (because ~delete~ is called on the static type not dynamic). In that case base class should suppress copying with ~=delete~ otherwise slice can happen. More info [[https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-copy-virtual][here]].

* Sources
1. [[https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md][C++ Guidelines]]
2. [[https://www.cprogramming.com/c++11/c++11-lambda-closures.html][C++ Lambda details]]
3. [[https://stackoverflow.com/questions/3106110/what-is-move-semantics][Move Semantics]]
4. [[https://www.youtube.com/watch?v=XRBS_QuB9h0][Rule of Three/Five/Zero]]
5. [[https://web.archive.org/web/20140113221447/http://cpp-next.com/archive/2009/08/want-speed-pass-by-value/][Want speed? Copy by value.]]
6. [[https://www.slideshare.net/ripplelabs/howard-hinnant-accu2014][Move semantics presentation, Howard Hinnant]]
7. [[https://www.modernescpp.com/index.php][Modern C++]]
