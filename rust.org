* Installation
** =rustup=
   #+BEGIN_SRC
   $ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
   #+END_SRC

* Commands
  - ~rustup update~
  - ~rustup doc~
  - ~cargo new project~
  - ~cargo build~
  - ~cargo run~
  - ~cargo check~
  - ~cargo doc --open~

* Variable vs. Constant
  By default everything is immutable. ~mut~ makes variable mutable. ~const~ must have type annotation and be known by compile time.

  - ~let x = 10;~                  // immutable
  - ~let mut x = 10;~              // mutable
  - ~const MAX_POINTS: u32 = 100;~ // constant

* Variable Shadowing 
  #+BEGIN_SRC rust
  fn main() {
      let x = 5;
      let x = x + 1; // ok
      x = 7; // not ok
  }
  #+END_SRC

* Data Types
** Scalar
   - Integer
   - Floating-point number
   - Boolean
   - Char

*** Integer
    Signed numbers are stored using twoâ€™s complement representation (e.g. i8 is from -128 to 127, u8 0 to 255).

    |---------+--------+----------+
    | Length  | Signed | Unsigned |
    |---------+--------+----------+
    | 8-bit   | i8     | u8       |
    | 16-bit  | i16    | u16      |
    | 32-bit  | i32    | u32      |
    | 64-bit  | i64    | u64      |
    | 128-bit | i128   | u128     |
    | arch    | isize  | usize    |
    |---------+--------+----------+
    
*** Floating-Point Types
    Default is ~f64~.

    |---------+-------+
    | Length  | Type  |
    |---------+-------+
    | 32-bit  | f32   |
    | 64-bit  | f64   |
    |---------+-------+

*** Boolean
    One byte in size.
    
    #+BEGIN_SRC rust
    fn main() {
        let t = true;
        let f: bool = false; // with explicit type annotation
    }
    #+END_SRC

*** Char
    Rustâ€™s char type is four bytes in size and represents a Unicode Scalar Value.

    #+BEGIN_SRC rust
    fn main() {
        let c = 'z';
        let z = 'â„¤';
        let heart_eyed_cat = 'ðŸ˜»';
    }
    #+END_SRC

** Compound
   - Tuple
   - Array

*** Tuple
    Can't grow or shrink.

    #+BEGIN_SRC rust
    fn main() {
        let tup: (i32, f64, u8) = (500, 6.4, 1);
        let tup = (500, 6.4, 1);
        let (x, y, z) = tup;
        println!(tup.x);
    }
    #+END_SRC

*** Array
    Can't grow or shrink (unlike ~Vector~).

    #+BEGIN_SRC rust
    fn main() {
        let a = [1, 2, 3, 4, 5];
        let a: [i32; 5] = [1, 2, 3, 4, 5];
        let a = [3; 5];
        let first = a[0];  // 3
        let second = a[1]; // 3
    }
    #+END_SRC

*** Functions
    Rust is a expression based language.

**** Statement
     Instructions that perform some action and do not return a value.

     #+BEGIN_SRC rust
     fn main() {    // statement
         let y = 6; // statement
     }
     #+END_SRC

**** Expressions
     Expressions evaluate to a resulting value.

     #+BEGIN_SRC rust
     fn main() {
         let x = 5;
         let y = {
             let x = 3;
             x + 1 // !!! without ; otherwise statement
         };
         println!("The value of y is: {}", y);
     }
     #+END_SRC

**** Return Value
     #+BEGIN_SRC rust
     fn five() -> i32 {
         5
     }
     fn plus_one(x: i32) -> i32 {
         x + 1         // !no ; ok
     }
     fn plus_one(x: i32) -> i32 {
         return x + 1; // ok
     }
     #+END_SRC
* Control Flow
  - if
  - loop
  - while
  - for

** ~if~
   #+BEGIN_SRC rust
   fn main() {
       let number = 6;
       if number % 4 == 0 {
           println!("number is divisible by 4");
       } else if number % 3 == 0 {
           println!("number is divisible by 3");
       } else {
           println!("number is not divisible by 4, 3, or 2");
       }
       let number = if 5 == 5 { 5 } else { 6 };
   }
   #+END_SRC

** ~loop~
   Loop until explicit stop.
   
   #+BEGIN_SRC rust
   fn main() {
       let mut counter = 0;
       let result = loop {
           counter += 1;
           if counter == 10 {
               break counter * 2;
           }
       };
       println!("The result is {}", result);
   }
   #+END_SRC

** ~while~
   #+BEGIN_SRC rust
   fn main() {
       let mut number = 3;
       while number != 0 {
           println!("{}!", number);
           number -= 1;
       }
       println!("LIFTOFF!!!");
   }
   #+END_SRC

** ~for~

   #+BEGIN_SRC rust
   fn main() {
       let a = [10, 20, 30, 40, 50];
       for element in a.iter() {
           println!("the value is: {}", element);
       }
   }
   #+END_SRC

   #+BEGIN_SRC rust
   fn main() {
       for number in (1..4).rev() {
           println!("{}!", number);
       }
       println!("LIFTOFF!!!");
   }
   #+END_SRC
* Ownership
  Rules of managing parts of heap memory that are no longer needed.
** Rules
   - Each value in Rust has a variable thatâ€™s called its owner.
   - There can only be one owner at a time.
   - When the owner goes out of scope, the value will be dropped (by calling ~drop~).

     #+BEGIN_SRC rust
     fn main() {
         let s1 = String::from("hello");
         let s2 = s1;
         println!("{}, world!", s1);
     }
     #+END_SRC
     #+BEGIN_SRC sh
     $ cargo run
        Compiling ownership v0.1.0 (file:///projects/ownership)
     error[E0382]: borrow of moved value: `s1`
      --> src/main.rs:5:28
       |
     2 |     let s1 = String::from("hello");
       |         -- move occurs because `s1` has type `std::string::String`, which does not implement the `Copy` trait
     3 |     let s2 = s1;
       |              -- value moved here
     4 | 
     5 |     println!("{}, world!", s1);
       |                            ^^ value borrowed here after move

     error: aborting due to previous error

     For more information about this error, try `rustc --explain E0382`.
     error: could not compile `ownership`.

     To learn more, run the command again with --verbose.
     #+END_SRC

     The concept of copying the pointer, length, and capacity without copying the data probably sounds like making a shallow copy. But because Rust also invalidates the first variable, instead of being called a shallow copy, itâ€™s known as a move. In this example, we would say that s1 was moved into s2.

** Ownership and Functions
   Passing a variable to a function will move or copy, just as assignment does.
   #+BEGIN_SRC rust
   fn main() {
       let s = String::from("hello");  // s comes into scope
       takes_ownership(s);             // s's value moves into the function...
                                       // ... and so is no longer valid here
       let x = 5;                      // x comes into scope
       makes_copy(x);                  // x would move into the function,
                                       // but i32 is Copy, so itâ€™s okay to still
                                       // use x afterward
   } // Here, x goes out of scope, then s. But because s's value was moved, nothing
     // special happens.
   
   fn takes_ownership(some_string: String) { // some_string comes into scope
       println!("{}", some_string);
   } // Here, some_string goes out of scope and `drop` is called. The backing
     // memory is freed.
   
   fn makes_copy(some_integer: i32) { // some_integer comes into scope
       println!("{}", some_integer);
   } // Here, some_integer goes out of scope. Nothing special happens.
   #+END_SRC

** Returns Values and Scope
   Returning values can also transfer ownership. The ownership of a variable follows the same pattern every time: assigning a value to another variable moves it. When a variable that includes data on the heap goes out of scope, the value will be cleaned up by drop unless the data has been moved to be owned by another variable.
   #+BEGIN_SRC rust
   fn main() {
       let s1 = gives_ownership();         // gives_ownership moves its return
                                           // value into s1
       let s2 = String::from("hello");     // s2 comes into scope
       let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                           // takes_and_gives_back, which also
                                           // moves its return value into s3
   } // Here, s3 goes out of scope and is dropped. s2 goes out of scope but was
     // moved, so nothing happens. s1 goes out of scope and is dropped.
   
   fn gives_ownership() -> String {             // gives_ownership will move its
                                                // return value into the function
                                                // that calls it
       let some_string = String::from("hello"); // some_string comes into scope
       some_string                              // some_string is returned and
                                                // moves out to the calling
                                                // function
   }
   
   // takes_and_gives_back will take a String and return one
   fn takes_and_gives_back(a_string: String) -> String { // a_string comes into
                                                         // scope
       a_string  // a_string is returned and moves out to the calling function
   }
   #+END_SRC
* Sources 
  - [1]: [[https://doc.rust-lang.org/book/title-page.html][Rust Book]]
* Pomodoros
  :LOGBOOK:
  CLOCK: [2020-06-23 Ãšt 08:25]
  CLOCK: [2020-06-22 Po 18:08]--[2020-06-22 Po 18:33] =>  0:25
  CLOCK: [2020-06-22 Po 16:44]--[2020-06-22 Po 17:09] =>  0:25
  :END:

