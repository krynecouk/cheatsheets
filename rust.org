* Installation
** =rustup=
   #+BEGIN_SRC
   $ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
   #+END_SRC

* Commands
  - ~rustup update~
  - ~rustup doc~
  - ~cargo new project~
  - ~cargo build~
  - ~cargo run~
  - ~cargo check~
  - ~cargo doc --open~
  - ~cargo test~
  - ~cargo test <name of test>~
  - ~cargo test <prefix of tests>~
    
* Variable vs. Constant
  By default everything is immutable. ~mut~ makes variable mutable. ~const~ must have type annotation and be known by compile time.

  - ~let x = 10;~                  // immutable
  - ~let mut x = 10;~              // mutable
  - ~const MAX_POINTS: u32 = 100;~ // constant

* Variable Shadowing 
  #+BEGIN_SRC rust
  fn main() {
      let x = 5;
      let x = x + 1; // ok
      x = 7; // not ok
  }
  #+END_SRC

* Data Types
** Scalar
   - Integer
   - Floating-point number
   - Boolean
   - Char

*** Integer
    Signed numbers are stored using two’s complement representation (e.g. i8 is from -128 to 127, u8 0 to 255).

    |---------+--------+----------+
    | Length  | Signed | Unsigned |
    |---------+--------+----------+
    | 8-bit   | i8     | u8       |
    | 16-bit  | i16    | u16      |
    | 32-bit  | i32    | u32      |
    | 64-bit  | i64    | u64      |
    | 128-bit | i128   | u128     |
    | arch    | isize  | usize    |
    |---------+--------+----------+
    
*** Floating-Point Types
    Default is ~f64~.

    |---------+-------+
    | Length  | Type  |
    |---------+-------+
    | 32-bit  | f32   |
    | 64-bit  | f64   |
    |---------+-------+

*** Boolean
    One byte in size.
    
    #+BEGIN_SRC rust
    fn main() {
        let t = true;
        let f: bool = false; // with explicit type annotation
    }
    #+END_SRC

*** Char
    Rust’s char type is four bytes in size and represents a Unicode Scalar Value.

    #+BEGIN_SRC rust
    fn main() {
        let c = 'z';
        let z = 'ℤ';
        let heart_eyed_cat = '😻';
    }
    #+END_SRC

** Compound
   - Tuple
   - Array

*** Tuple
    Can't grow or shrink.

    #+BEGIN_SRC rust
    fn main() {
        let tup: (i32, f64, u8) = (500, 6.4, 1);
        let tup = (500, 6.4, 1);
        let (x, y, z) = tup;
        println!(tup.x);
    }
    #+END_SRC

*** Array
    Can't grow or shrink (unlike ~Vector~).

    #+BEGIN_SRC rust
    fn main() {
        let a = [1, 2, 3, 4, 5];
        let a: [i32; 5] = [1, 2, 3, 4, 5];
        let a = [3; 5];
        let first = a[0];  // 3
        let second = a[1]; // 3
    }
    #+END_SRC

*** Functions
    Rust is a expression based language.

**** Statement
     Instructions that perform some action and do not return a value.

     #+BEGIN_SRC rust
     fn main() {    // statement
         let y = 6; // statement
     }
     #+END_SRC

**** Expressions
     Expressions evaluate to a resulting value.

     #+BEGIN_SRC rust
     fn main() {
         let x = 5;
         let y = {
             let x = 3;
             x + 1 // !!! without ; otherwise statement
         };
         println!("The value of y is: {}", y);
     }
     #+END_SRC

**** Return Value
     #+BEGIN_SRC rust
     fn five() -> i32 {
         5
     }
     fn plus_one(x: i32) -> i32 {
         x + 1         // !no ; ok
     }
     fn plus_one(x: i32) -> i32 {
         return x + 1; // ok
     }
     #+END_SRC
* Control Flow
  - if
  - loop
  - while
  - for

** ~if~
   #+BEGIN_SRC rust
   fn main() {
       let number = 6;
       if number % 4 == 0 {
           println!("number is divisible by 4");
       } else if number % 3 == 0 {
           println!("number is divisible by 3");
       } else {
           println!("number is not divisible by 4, 3, or 2");
       }
       let number = if 5 == 5 { 5 } else { 6 };
   }
   #+END_SRC

** ~loop~
   Loop until explicit stop.
   
   #+BEGIN_SRC rust
   fn main() {
       let mut counter = 0;
       let result = loop {
           counter += 1;
           if counter == 10 {
               break counter * 2;
           }
       };
       println!("The result is {}", result);
   }
   #+END_SRC

** ~while~
   #+BEGIN_SRC rust
   fn main() {
       let mut number = 3;
       while number != 0 {
           println!("{}!", number);
           number -= 1;
       }
       println!("LIFTOFF!!!");
   }
   #+END_SRC

** ~for~

   #+BEGIN_SRC rust
   fn main() {
       let a = [10, 20, 30, 40, 50];
       for element in a.iter() {
           println!("the value is: {}", element);
       }
   }
   #+END_SRC

   #+BEGIN_SRC rust
   fn main() {
       for number in (1..4).rev() {
           println!("{}!", number);
       }
       println!("LIFTOFF!!!");
   }
   #+END_SRC
** ~match~
   Pattern matching +operator+ expression.
   #+BEGIN_SRC 
   match <expression> {
      <pattern> => <some code>
   }
   #+END_SRC

   #+BEGIN_SRC rust
   fn main() {
       fn plus_one(x: Option<i32>) -> Option<i32> {
           match x {
               None => None,
               Some(i) => Some(i + 1),
           }
       }
   
       let five = Some(5);
       let six = plus_one(five);
       let none = plus_one(None);
   }
   #+END_SRC
** ~if let~
   Shorthand for ~match~ with only one pattern.
   #+BEGIN_SRC 
   if let <pattern> = <expression> {<some code>}
   #+END_SRC
   This:
   #+BEGIN_SRC rust
   fn main() {
       let some_u8_value = Some(0u8);
       match some_u8_value {
           Some(3) => println!("three"),
           _ => (),
       }
   }
   #+END_SRC
   Is same as this:
   #+BEGIN_SRC rust
   fn main() {
       let some_u8_value = Some(0u8);
       if let Some(3) = some_u8_value {
          println!("three")
       } else {
          ...
       }
   }
   
   #+END_SRC
* Ownership
  Rules of managing parts of heap memory that are no longer needed. For every value in heap there is only one variable on stack (owner of the value).
** Rules
   - Each value in Rust has a variable that’s called its owner.
   - There can only be one owner at a time.
   - When the owner goes out of scope, the value will be dropped (by calling ~drop~).

     #+BEGIN_SRC rust
     fn main() {
         let s1 = String::from("hello");
         let s2 = s1;
         println!("{}, world!", s1);
     }
     #+END_SRC
     #+BEGIN_SRC sh
     $ cargo run
        Compiling ownership v0.1.0 (file:///projects/ownership)
     error[E0382]: borrow of moved value: `s1`
      --> src/main.rs:5:28
       |
     2 |     let s1 = String::from("hello");
       |         -- move occurs because `s1` has type `std::string::String`, which does not implement the `Copy` trait
     3 |     let s2 = s1;
       |              -- value moved here
     4 | 
     5 |     println!("{}, world!", s1);
       |                            ^^ value borrowed here after move

     error: aborting due to previous error

     For more information about this error, try `rustc --explain E0382`.
     error: could not compile `ownership`.

     To learn more, run the command again with --verbose.
     #+END_SRC

     The concept of copying the pointer, length, and capacity without copying the data probably sounds like making a shallow copy. But because Rust also invalidates the first variable, instead of being called a shallow copy, it’s known as a move. In this example, we would say that s1 was moved into s2.

** Ownership and Functions
   Passing a variable to a function will move or copy, just as assignment does.
   #+BEGIN_SRC rust
   fn main() {
       let s = String::from("hello");  // s comes into scope
       takes_ownership(s);             // s's value moves into the function...
                                       // ... and so is no longer valid here
       let x = 5;                      // x comes into scope
       makes_copy(x);                  // x would move into the function,
                                       // but i32 is Copy, so it’s okay to still
                                       // use x afterward
   } // Here, x goes out of scope, then s. But because s's value was moved, nothing
     // special happens.
   
   fn takes_ownership(some_string: String) { // some_string comes into scope
       println!("{}", some_string);
   } // Here, some_string goes out of scope and `drop` is called. The backing
     // memory is freed.
   
   fn makes_copy(some_integer: i32) { // some_integer comes into scope
       println!("{}", some_integer);
   } // Here, some_integer goes out of scope. Nothing special happens.
   #+END_SRC

** Returns Values and Scope
   Returning values can also transfer ownership. The ownership of a variable follows the same pattern every time: assigning a value to another variable moves it. When a variable that includes data on the heap goes out of scope, the value will be cleaned up by drop unless the data has been moved to be owned by another variable.
   #+BEGIN_SRC rust
   fn main() {
       let s1 = gives_ownership();         // gives_ownership moves its return
                                           // value into s1
       let s2 = String::from("hello");     // s2 comes into scope
       let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                           // takes_and_gives_back, which also
                                           // moves its return value into s3
   } // Here, s3 goes out of scope and is dropped. s2 goes out of scope but was
     // moved, so nothing happens. s1 goes out of scope and is dropped.
   
   fn gives_ownership() -> String {             // gives_ownership will move its
                                                // return value into the function
                                                // that calls it
       let some_string = String::from("hello"); // some_string comes into scope
       some_string                              // some_string is returned and
                                                // moves out to the calling
                                                // function
   }
   
   // takes_and_gives_back will take a String and return one
   fn takes_and_gives_back(a_string: String) -> String { // a_string comes into
                                                         // scope
       a_string  // a_string is returned and moves out to the calling function
   }
   #+END_SRC

* References and Borowing
  References allow you to refer to some value without taking ownership of it. Because it does not own it, the value it points to will not be dropped when the reference goes out of scope.
  
  #+BEGIN_SRC rust
  fn main() {
      let s1 = String::from("hello");
      let len = calculate_length(&s1);
      println!("The length of '{}' is {}.", s1, len);
  }
  
  fn calculate_length(s: &String) -> usize { // s is a reference to a String
      s.len()
  } // Here, s goes out of scope. But because it does not have ownership of what
    // it refers to, nothing happens.
  #+END_SRC

** Rules
   - At any given time, you can have either one mutable reference or any number of immutable references.
   - References must always be valid (must have value to borrow from).

   #+BEGIN_SRC rust
   fn main() {
       let mut s = String::from("hello");
       let r1 = &mut s;
       let r2 = &mut s;
       println!("{}, {}", r1, r2); // error[E0499]: cannot borrow `s` as mutable more than once at a time
   }
   #+END_SRC

* Slices
  Reference to a contiguous sequence of elements in a collection rather than the whole collection.
** String Slice
   A string slice is a reference to part of a String.
   
   String slices are when using:
   - ranges
   - literals (stored in binary as sequence of strings)
   
   #+BEGIN_SRC rust
   fn main() {
       let s = String::from("hello world");
       let hello = &s[0..5];
       let world = &s[6..11];
   }
   #+END_SRC

** Array Slice
   #+BEGIN_SRC rust
   let a = [1, 2, 3, 4, 5];
   let slice = &a[1..3];
   #+END_SRC

* Structs 
  Object definition (structure). Unlike tuples, strucs attribute doesn't have to be in the same order.

** Struct Types
   - basic struct
   - tuple struct
   - unit-like struct

*** Basic Struct
  
    #+BEGIN_SRC rust
    ...
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
    ...
    #+END_SRC

**** Update Syntax (spread)
     #+BEGIN_SRC rust
     ...
     let user1 = User {
         email: String::from("someone@example.com"),
         username: String::from("someusername123"),
         active: true,
         sign_in_count: 1,
     };
   
     let user2 = User {
         email: String::from("another@example.com"),
         username: String::from("anotherusername567"),
         ..user1
     };
     ...
     #+END_SRC

*** Tuple Struct
    Struct with name but don’t have names associated with their fields; rather, they just have the types of the fields.

    #+BEGIN_SRC rust
    fn main() {
        struct Color(i32, i32, i32);
        let black = Color(0, 0, 0);
    }
    #+END_SRC

*** Unit-like Struct
    Struct without any field.

** Struct Methods
   #+BEGIN_SRC rust
   struct Rectangle {
       width: u32,
       height: u32,
   }
   impl Rectangle {
       fn can_hold(&self, other: &Rectangle) -> bool {
           self.width > other.width && self.height > other.height
       }
   }
   fn main() {
       let rect1 = Rectangle {
           width: 30,
           height: 50,
       };
       let rect2 = Rectangle {
           width: 10,
           height: 40,
       };

       println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
   }
   #+END_SRC

*** Automatic (De)Referencing
    Here’s how it works: when you call a method with object.something(), Rust automatically adds in &, &mut, or * so object matches the signature of the method. In other words, the following are the same:
    #+BEGIN_SRC rust
    p1.distance(&p2);
    (&p1).distance(&p2);
    #+END_SRC

** Associated Functions
   Like ~static~. Recognized by missing ~self~.

   #+BEGIN_SRC rust
   struct Rectangle {
       width: u32,
       height: u32,
   }
    
   impl Rectangle {
       fn square(size: u32) -> Rectangle {
           Rectangle {
               width: size,
               height: size,
           }
       }
   }
    
   fn main() {
       let sq = Rectangle::square(3);
   }
   #+END_SRC

* Enums 
  #+BEGIN_SRC rust
  fn main() {
      enum Message {
          Quit,
          Move { x: i32, y: i32 },
          Write(String),
          ChangeColor(i32, i32, i32),
      }
  
      impl Message {
          fn call(&self) {
              // method body would be defined here
          }
      }
  
      let m = Message::Write(String::from("hello"));
      m.call();
  }
  #+END_SRC

* Packages, crates and modules 
  - Packages: A Cargo feature that lets you build, test, and share crates
  - Crates: A tree of modules that produces a library or executable
  - Modules and use: Let you control the organization, scope, and privacy of paths
  - Paths: A way of naming an item, such as a struct, function, or module

** Packages
   A package is one or more crates that provide a set of functionality. A package contains a Cargo.toml file that describes how to build those crates.
*** Rules
    - package *must* contain 0 or 1 library crate;
    - package *can* contain 0 or N binary crates;
    - package *must* contain at least 1 crate (either library or binary);

** Crate
   A crate is a binary or library.
*** Rules
    - if ~main.rs~ then it's binary crate;
    - if ~lib.rs~ then its's library crate;
    - both are =crate-roots=

** Modules
   Modules let us organize code within a crate into groups for readability and easy reuse.
   
   #+BEGIN_SRC rust
   mod front_of_house {
       mod hosting {
           fn add_to_waitlist() {}
           fn seat_at_table() {}
       }
   
       mod serving {
           fn take_order() {}
           fn serve_order() {}
           fn take_payment() {}
       }
   }
   #+END_SRC
   
   Represents module tree:
   #+BEGIN_SRC 
   crate
    └── front_of_house
        ├── hosting
        │   ├── add_to_waitlist
        │   └── seat_at_table
        └── serving
            ├── take_order
            ├── serve_order
            └── take_payment
   #+END_SRC

** Path
   Way of finding item in module tree.

*** Absolute
    Starts from a crate root by using a crate name or a literal crate.
    
    #+BEGIN_SRC rust
     pub fn eat_at_restaurant() {
         // Absolute path
         crate::front_of_house::hosting::add_to_waitlist();
     }
    #+END_SRC

*** Relative
    Starts from the current module and uses self, super, or an identifier in the current module.
     
    #+BEGIN_SRC rust
     pub fn eat_at_restaurant() {
         // Relative path
         front_of_house::hosting::add_to_waitlist();
     }
    #+END_SRC

**** ~super~
     Analogy to ~..~ in shell.

**** ~self~
     Analogy to ~.~ in shell.

*** ~pub~ keyword
    All items are private by default. Parent module can't see to the child module. Child module can access parent. In order to expose parts of module, use ~pub~.

*** ~use~ keyword
    Adding use and a path in a scope is similar to creating a symbolic link in the filesystem.

    #+BEGIN_SRC rust
    use std::fmt::Result;
    pub use std::io::Result as IoResult;
    #+END_SRC

*** nested ~use~ paths
    #+BEGIN_SRC rust
    use std::cmp::Ordering;
    use std::io;
    #+END_SRC
    
    Is the same as:
    #+BEGIN_SRC rust
    use std::{cmp::Ordering, io};
    #+END_SRC

*** glob ~use~ operator
    #+BEGIN_SRC rust
    use std::collections::*;
    #+END_SRC

*** ~mod~ without ~{}~
    Loads content of different module. Must be included in ~use~ of module in different file.
    
    #+BEGIN_SRC rust
    mod front_of_house;
    pub use crate::front_of_house::hosting;
    #+END_SRC
* Collections
  - Vector
  - String
  - Hash Map
** Vector
   List of elements of the same type.
   
   #+BEGIN_SRC rust
   fn main() {
       let v1: Vec<i32> = Vec::new();
       let v2 = vec![1, 2, 3];
       let mut v3 = Vec::new();
       v3.push(5);
       let does_not_exist = &v2[100];    // panic
       let does_not_exist = v2.get(100); // None

       for i in &v2 {
           println!("{}", i);
       }
   }
   #+END_SRC
** String
   Rust core lang uses and knows *only* /string slice/ (~str~ or in borrowed form ~&str~). Reference to some UTF-8 encoded string in binary.

   ~String~ type comes from ~std~ library. Represents growable, mutable, owned, UTF-8 encoded string type. There are another string types in ~std~ like ~OsString~, ~OsStr~, ~CString~ and ~CStr~.
   
   ~String~ is just a wrapper aroud ~Vec<u8>~.
   
   ~String~ is represented as bytes, scalar values or grapheme clusters. That is the reason why rust don't know how to index ~String~ (which form of string?).
   
   #+BEGIN_SRC rust
   let mut s1 = String::from("foo");
   let s2 = "bar";
   s1.push_str(s2);
   println!("s2 is {}", s2);

   let s1 = String::from("tic");
   let s2 = String::from("tac");
   let s3 = String::from("toe");
   let s = format!("{}-{}-{}", s1, s2, s3);

   let hello = "Здравствуйте";
   // let answer = &hello[0]; // compile error
   hello.chars(); // ok
   hello.bytes(); // ok
   #+END_SRC

** Hash Map
   The type ~HashMap<K, V>~ stores a mapping of keys of type K to values of type V.
   
   #+BEGIN_SRC rust
   fn main() {
       use std::collections::HashMap;
       let mut scores = HashMap::new();
       scores.insert(String::from("Yellow"), 50);
       scores.entry(String::from("Yellow")).or_insert(50); // check if exists and if not then insert
   }
   #+END_SRC

* Error Handling 
  - Unrecoverable (~!panic~)
  - Recoverable (~Result<T, E>~)

** Unrecoverable (~!panic~)
   Print a failure message, unwind and clean up the stack, and then quit.
   
   #+BEGIN_SRC rust
   fn main() {
       panic!("crash and burn");
   }
   #+END_SRC
   
   #+BEGIN_SRC shell
   $ RUST_BACKTRACE=1 cargo run
   #+END_SRC

** Recoverable (~Result<T, E>~)
   #+BEGIN_SRC rust
   enum Result<T, E> {
       Ok(T),
       Err(E),
   }
   #+END_SRC
   
   #+BEGIN_SRC rust
   use std::fs::File;
   use std::io::ErrorKind;
   
   fn main() {
       let f = File::open("hello.txt");
       let f = match f {
           Ok(file) => file,
           Err(error) => match error.kind() {
               ErrorKind::NotFound => match File::create("hello.txt") {
                   Ok(fc) => fc,
                   Err(e) => panic!("Problem creating the file: {:?}", e),
               },
               other_error => {
                   panic!("Problem opening the file: {:?}", other_error)
               }
           },
       };
   }
   #+END_SRC
*** ~unwrap~ and ~expect~
    #+BEGIN_SRC rust
    fn main() {
        let f = File::open("hello.txt").unwrap();
        let f = File::open("hello.txt").expect("Failed to open hello.txt");
    }
    #+END_SRC
*** propagate error operator ~?~
    If ~open~ returns ~Err~ then return from function ~read_username_from_file~ an ~Err~. Otherwise return ~Ok~.
    #+BEGIN_SRC rust
    use std::fs::File;
    use std::io;
    use std::io::Read;
    
    fn read_username_from_file() -> Result<String, io::Error> {
        let mut s = String::new();
    
        File::open("hello.txt")?.read_to_string(&mut s)?;
    
        Ok(s)
    }
    #+END_SRC

* Generic Types 
  #+BEGIN_SRC rust
  fn largest<T>(list: &[T]) -> T {...}

  struct Point<T> {
      x: T,
      y: T,
  }

  impl<T> Point<T> {
      fn x(&self) -> &T {
          &self.x
      }
  }
  #+END_SRC

* Trait
  A trait tells the Rust compiler about functionality a particular type has and can share with other types (~interface).
  
  #+BEGIN_SRC rust
  #![allow(unused_variables)]
  trait Summary {
      fn summarize(&self) -> String;
  }

  trait DefaultSummary {
      fn summarize(&self) -> String {
          "foo".to_string();
      }
  }

  struct NewsArticle {
      pub headline: String,
      pub location: String,
      pub author: String,
      pub content: String,
  }

  impl Summary for NewsArticle {
      fn summarize(&self) -> String {
          format!("{}, by {} ({})", self.headline, self.author, self.location)
      }
  }

  // this
  fn notify(item: &impl Summary) {
      println!("Breaking news! {}", item.summarize());
  }

  // same as this
  fn notify<T: Summary>(item: &T) {
      println!("Breaking news! {}", item.summarize());
  }
  #+END_SRC

** Trait Bounds
   #+BEGIN_SRC rust
   // must implement ~Summary~ AND ~Display~
   pub fn notify(item: &(impl Summary + Display)) {}

   // same
   pub fn notify<T: Summary + Display>(item: &T) {}
   
   // with where trait bound
   fn some_function<T, U>(t: &T, u: &U) -> i32
       where T: Display + Clone,
             U: Clone + Debug
   {}
   #+END_SRC

** Blanket Implementations
   Implement a trait for any type that implements an another trait.
   
   #+BEGIN_SRC rust
   // Implement ~ToString~ for any ~is-a Display~
   impl<T: Display> ToString for T {}
   #+END_SRC

* Lifetimes
  Every reference in Rust has a /lifetime/, which is the scope for which that reference is valid.
  #+BEGIN_SRC rust
  fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
      if x.len() > y.len() {
          x
      } else {
          y
      }
  }
  #+END_SRC

** Borrow Checker
   Rust checks if the inner scopes lives long as the outer ones.
   - Short life
     #+BEGIN_SRC 
     fn main() {
         {
             let r;                // ---------+-- 'a
             {                     //          |
                 let x = 5;        // -+-- 'b  |
                 r = &x;           //  |       |
             }                     // -+       |
             println!("r: {}", r); //          |
         }                         // ---------+
     }
     #+END_SRC

   - Long life
     #+BEGIN_SRC rust
     fn main() {
         {
             let x = 5;            // ----------+-- 'b
                                   //           |
             let r = &x;           // --+-- 'a  |
                                   //   |       |
             println!("r: {}", r); //   |       |
         }                         // ----------+
     }
     #+END_SRC

** Lifetime Elision Rules
   1. Implicit lifetimes
      Every function gets an implicit lifetime.

   2. output lifetime
      If one input lifetime then the output's lifetime is the same.

   3. ~self~ lifetime
      If multiple input lifetimes but one is ~&self~ or ~&mut self~ then output lifetime is that of ~self~.

   4. other
      If none of above then the lifetime annotation must be specified.
* Testing
  - ~assert!~
    #+BEGIN_SRC rust
    #[cfg(test)]
    mod tests {
        use super::*;
        #[test]
        fn greeting_contains_name() {
            let result = greeting("Carol");
            assert!(
                result.contains("Carol"),
                "Greeting did not contain name, value was `{}`", result
            );
        }
    }
    #+END_SRC
  - ~assert_eq!~
    #+BEGIN_SRC rust
    pub fn add_two(a: i32) -> i32 {
        a + 2
    }
    
    #[cfg(test)]
    mod tests {
        use super::*;
    
        #[test]
        fn it_adds_two() {
            assert_eq!(4, add_two(2));
        }
    }
    #+END_SRC
  - ~assert_ne!~
  - ~[should_panic]~
    #+BEGIN_SRC rust
    #[test]
    #[should_panic(expected = "Guess value must be less than or equal to 100")]
    fn greater_than_100() {
        Guess::new(200);
    }
    #+END_SRC
  - ~[ignore]~
  - custom
    #+BEGIN_SRC rust
    #[test]
    fn it_works() -> Result<(), String> {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from("two plus two does not equal four"))
        }
    }
    #+END_SRC
** Unit
   - Small and more focused, testing one module in isolation at a time, and can test private interfaces.
   - In the code which testing (module ~tests~ with ~cfg(test)~).
     #+BEGIN_SRC rust
     fn main() {...}

     #[cfg(test)]
     mod tests {
         use super::*;
         #[test]
         ...
     }
     #+END_SRC
   - ~cfg(test)~ (configuration) tells compiler to not include test code in the build.
** Integration
   - Entirely external to your library and use your code in the same way any other external code would, using only the public interface and potentially exercising multiple modules per test.
   - In =crate/tests/<name>_test.rs=.
   - ~common~ functions must be in =tests/common/mod.rs=
     #+BEGIN_SRC rust
     mod common;
     
     #[test]
     fn it_adds_two() {
         common::setup();
         assert_eq!(4, adder::add_two(2));
     }
     #+END_SRC
* Closures
  #+BEGIN_SRC rust
  fn  add_one_v1   (x: u32) -> u32 { x + 1 }
  let add_one_v2 = |x: u32| -> u32 { x + 1 };
  let add_one_v3 = |x|             { x + 1 };
  let add_one_v4 = |x|               x + 1  ;
  #+END_SRC
* Iterator
  - /iterator adaptors/  - allow to change iterators into different kinds of iterators (e.g. ~map~, ~fileter~ etc)
  - /consuming adaptors/ - get result of iterator (e.g. ~collect~)

    #+BEGIN_SRC rust
    pub trait Iterator {
        type Item;
        fn next(&mut self) -> Option<Self::Item>;
        // methods with default implementations elided
    }
    #+END_SRC
    #+BEGIN_SRC rust
    let sum: u32 = Counter::new()
        .zip(Counter::new().skip(1))
        .map(|(a, b)| a * b)
        .filter(|x| x % 3 == 0)
        .sum();
    #+END_SRC
* Comment
** Documentation Comment
   #+BEGIN_SRC rust
   /// Adds one to the number given.
   ///
   /// # Examples
   ///
   /// ```
   /// let arg = 5;
   /// let answer = my_crate::add_one(arg);
   ///
   /// assert_eq!(6, answer);
   /// ```
   pub fn add_one(x: i32) -> i32 {
   x + 1
   }
   #+END_SRC
** Items Comment
   #+BEGIN_SRC rust
   //! # My Crate
   //!
   //! `my_crate` is a collection of utilities to make performing certain
   //! calculations more convenient.
   #+END_SRC
* Cargo Workspace
  #+BEGIN_SRC rust
  [workspace]
  members = [
      "adder",
      "add-one",
  ]
  #+END_SRC
  #+BEGIN_SRC rust
  [dependencies]
  add-one = { path = "../add-one" }
  #+END_SRC
* ~Deref~ Trait
  Implementing the Deref trait allows to customize the behavior of the dereference operator ~*~.
  #+BEGIN_SRC rust
  use std::ops::Deref;
  struct MyBox<T>(T);
  impl<T> MyBox<T> {
      fn new(x: T) -> MyBox<T> {
          MyBox(x)
      }
  }
  impl<T> Deref for MyBox<T> {
      type Target = T;
  
      fn deref(&self) -> &T {
          &self.0
      }
  }
  #+END_SRC
** ~Deref~ Coercion
   /Deref coercion/ is a convenience that Rust performs on arguments to functions and methods. Deref coercion works only on types that implement the Deref trait. Deref coercion converts such a type into a reference to another type.

   - From ~&T~ to ~&U~ when ~T: Deref<Target=U>~
   - From ~&mut T~ to ~&mut U~ when ~T: DerefMut<Target=U>~
   - From ~&mut T~ to ~&U~ when ~T: Deref<Target=U>~

* ~Drop~ Trait
  Particular bit of code to be run whenever a value goes out of scope, and the compiler will insert this code automatically.
  
  #+BEGIN_SRC rust
  struct CustomSmartPointer {
    data: String,
  }

  impl Drop for CustomSmartPointer {
      fn drop(&mut self) {
          println!("Dropping CustomSmartPointer with data `{}`!", self.data);
      }
  }
  
  fn main() {
      let c = CustomSmartPointer {
          data: String::from("my stuff"),
      };
      let d = CustomSmartPointer {
          data: String::from("other stuff"),
      };
      println!("CustomSmartPointers created.");
  }
  #+END_SRC

* Smart Pointers
  Data structures (usually ~struct~ with ~Deref~ and ~Drop~ traits) that not only act like a pointer but also have additional metadata and capabilities (e.g. ~String~ or ~Vec<T>~).
  - ~Box<T>~
  - ~Rc<T>~
  - ~Ref<T>~
  - ~RefMut<T>~
** ~Box<T>~
   All values in Rust are stack allocated by default. Values can be boxed (allocated on the heap) by creating a Box<T>

   #+BEGIN_SRC rust
   fn main() {
       let b = Box::new(5);
       println!("b = {}", b);
   }
   #+END_SRC

   - When you have a type whose size can’t be known at compile time and you want to use a value of that type in a context that requires an exact size
   - When you have a large amount of data and you want to transfer ownership but ensure the data won’t be copied when you do so
   - When you want to own a value and you care only that it’s a type that implements a particular trait rather than being of a specific type
** ~Rc<T>~
   Keeps track of the number of references to a value which determines whether or not a value is still in use. If there are zero references to a value, the value can be cleaned up without any references becoming invalid.

   #+BEGIN_SRC rust
   fn main() {
      let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
      println!("count after creating a = {}", Rc::strong_count(&a));          // 1
      let b = Cons(3, Rc::clone(&a));
      println!("count after creating b = {}", Rc::strong_count(&a));          // 2
      {
          let c = Cons(4, Rc::clone(&a));
          println!("count after creating c = {}", Rc::strong_count(&a));      // 3
      }
      println!("count after c goes out of scope = {}", Rc::strong_count(&a)); // 2
   }
   #+END_SRC
** ~RefCell<T>~
   Type that we can use when we need an immutable type but need to change an inner value of that type; it also enforces the borrowing rules at runtime instead of at compile time.
* Threads
  - M:N - /green/ threads - M language threads : N OS threads
  - 1:1 - 1 language thread : 1 OS thread (used in Rust)
    #+BEGIN_SRC rust
    fn main() {
        let v = vec![1, 2, 3];
        let handle = thread::spawn(move || {
            println!("Here's a vector: {:?}", v);
        });
        handle.join().unwrap();
    }
    #+END_SRC
  - ~move~ moves ownership to the closure (default is immutable borrow)

* Channels
  Do not communicate by sharing memory; instead, share memory by communicating.
  #+BEGIN_SRC rust
  use std::sync::mpsc;    // multiple producers, single consumer
  use std::thread;
  use std::time::Duration;
  fn main() {
      // tx - transmitter (producer)
      // rx - receiver (consumer)
      let (tx, rx) = mpsc::channel();
      let tx1 = mpsc::Sender::clone(&tx);
      thread::spawn(move || {
          let vals = vec![
              String::from("hi"),
              String::from("from"),
              String::from("the"),
              String::from("thread"),
          ];
  
          for val in vals {
              tx1.send(val).unwrap();
              thread::sleep(Duration::from_secs(1));
          }
      });
  
      thread::spawn(move || {
          let vals = vec![
              String::from("more"),
              String::from("messages"),
              String::from("for"),
              String::from("you"),
          ];
  
          for val in vals {
              tx.send(val).unwrap();
              thread::sleep(Duration::from_secs(1));
          }
      });
  
      for received in rx {
          println!("Got: {}", received);
      }
  }
  #+END_SRC
* Mutex
  Communication by sharing memory.
  #+BEGIN_SRC rust
  use std::sync::{Arc, Mutex};
  use std::thread;

  fn main() {
      let counter = Arc::new(Mutex::new(0)); // Atomic version of ~Rc<T>~
      let mut handles = vec![];
  
      for _ in 0..10 {
          let counter = Arc::clone(&counter);
          let handle = thread::spawn(move || {
              let mut num = counter.lock().unwrap();
  
              *num += 1;
          });
          handles.push(handle);
      }
  
      for handle in handles {
          handle.join().unwrap();
      }
  
      println!("Result: {}", *counter.lock().unwrap());
  }
  #+END_SRC
* ~async~/~await~ 
  #+BEGIN_SRC rust
  async fn learn_and_sing() {
    // Wait until the song has been learned before singing it.
    // We use `.await` here rather than `block_on` to prevent blocking the
    // thread, which makes it possible to `dance` at the same time.
    let song = learn_song().await;
    sing_song(song).await;
  }

  async fn async_main() {
      let f1 = learn_and_sing();
      let f2 = dance();
  
      // `join!` is like `.await` but can wait for multiple futures concurrently.
      // If we're temporarily blocked in the `learn_and_sing` future, the `dance`
      // future will take over the current thread. If `dance` becomes blocked,
      // `learn_and_sing` can take back over. If both futures are blocked, then
      // `async_main` is blocked and will yield to the executor.
      futures::join!(f1, f2);
  }
  
  fn main() {
      block_on(async_main());
  }
  #+END_SRC
* Trait Object
  Any type inside a ~Box~ (or ~&~) that implements the trait and:
  - The return type isn’t Self.
  - There are no generic type parameters.

  #+BEGIN_SRC rust
  pub struct Screen {
      pub components: Vec<Box<dyn Draw>>,
  }
  #+END_SRC
* Pattern Matching
** Syntax
*** ~let~
    #+BEGIN_SRC 
    let PATTERN = EXPRESSION;
    #+END_SRC

*** ~fn~
    #+BEGIN_SRC 
    fn foo(PATTERN)
    #+END_SRC

*** ~match~
    #+BEGIN_SRC 
    match VALUE {
        PATTERN => EXPRESSION,
        PATTERN => EXPRESSION,
        PATTERN => EXPRESSION,
    }
    #+END_SRC

*** ~if let~
    #+BEGIN_SRC 
    if let PATTERN = VALUE {
        EXPRESSION
    }
    #+END_SRC

*** ~while let~
    #+BEGIN_SRC 
    while let PATTERN = VALUE {
        EXPRESSION
    }
    #+END_SRC

*** ~for~
    #+BEGIN_SRC 
    for PATTERN in VALUE {
        EXPRESSION
    }
    #+END_SRC
** refutable
   Patterns that can fail to match for some possible value (e.g. ~let Some(x) = a_value~).
   - *can*: ~if let~, ~while let~

** irrefutable 
   Patterns that will match for any possible value passed (e.g. ~let x = 5~).
   - *must*: ~let~, ~fn~, ~for~
   - *can*: ~if let~, ~while let~ (but with warning because always matched)
** examples
*** Multiple Patterns
    #+BEGIN_SRC rust
    let x = 1;
    match x {
        1 | 2 => println!("one or two"),
        3 => println!("three"),
        _ => println!("anything"),
    }
    #+END_SRC
*** Matching Ranges
    #+BEGIN_SRC rust
    let x = 'c';
    match x {
        'a'..='j' => println!("early ASCII letter"),
        'k'..='z' => println!("late ASCII letter"),
        _ => println!("something else"),
    }
    #+END_SRC
*** Destructing ~struct~
    #+BEGIN_SRC rust
    struct Point {
        x: i32,
        y: i32
    }
    
    fn foo() {
        let point = Point { x: 10 y: 20 };
        let Point { x: a, b: y} = point; // OK
        let Point { x, y } = point;      // OK
    }
    #+END_SRC
*** Destructing ~enum~
    #+BEGIN_SRC rust
    enum Color {
        Rgb(i32, i32, i32),
        Hsv(i32, i32, i32),
    }
    
    enum Message {
        Quit,
        Move { x: i32, y: i32 },
        Write(String),
        ChangeColor(Color),
    }    

    fn main() {
        let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));
    
        match msg {
            Message::ChangeColor(Color::Rgb(r, g, b)) => println!(
                "Change the color to red {}, green {}, and blue {}",
                r, g, b
            ),
            Message::ChangeColor(Color::Hsv(h, s, v)) => println!(
                "Change the color to hue {}, saturation {}, and value {}",
                h, s, v
            ),
            _ => (),
        }
    }
    #+END_SRC

*** Desctructing ~struct~ and ~tuple~
    #+BEGIN_SRC rust
    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
    #+END_SRC

*** Ingoring Value
    #+BEGIN_SRC rust
    fn foo(_: i32, y: i32) {
        println!("This code only uses the y parameter: {}", y);
    }
    #+END_SRC

*** Ignoring Remaining Parts
    #+BEGIN_SRC rust
    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } => println!("x is {}", x),
    }
    #+END_SRC

*** Match Guards
    #+BEGIN_SRC rust
    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } => println!("x is {}", x),
    }
    #+END_SRC

*** ~@~ Bindings
    #+BEGIN_SRC rust
    fn main() {
        enum Message {
            Hello { id: i32 },
        }

        let msg = Message::Hello { id: 5 };

        match msg {
            Message::Hello { id: foo @ 3..=7 } => println!("Found an id in range: {}", foo),
            Message::Hello { id: 10..=12 } => println!("Found an id in another range"),
            Message::Hello { id } => println!("Found some other id: {}", id),
        }
    }
    #+END_SRC
* Sources 
  - [1]: [[https://doc.rust-lang.org/book/title-page.html][Rust Book]]
  - [2]: [[https://doc.rust-lang.org/stable/rust-by-example/index.html][Rust By Example]]
  - [3]: [[https://rust-unofficial.github.io/too-many-lists/index.html][Rust Linked List]]
  - [4]: [[https://doc.rust-lang.org/nomicon/index.html][Rust Rustonomicon]]
* Pomodoros
  :LOGBOOK:
  CLOCK: [2020-07-08 St 21:23]
  CLOCK: [2020-07-08 St 09:53]--[2020-07-08 St 10:18] =>  0:25
  CLOCK: [2020-07-08 St 09:17]--[2020-07-08 St 09:42] =>  0:25
  CLOCK: [2020-07-07 Út 15:38]--[2020-07-07 Út 16:03] =>  0:25
  CLOCK: [2020-07-06 Po 21:43]--[2020-07-06 Po 22:08] =>  0:25
  CLOCK: [2020-07-06 Po 21:11]--[2020-07-06 Po 21:36] =>  0:25
  CLOCK: [2020-07-06 Po 17:36]--[2020-07-06 Po 18:01] =>  0:25
  CLOCK: [2020-07-06 Po 13:07]--[2020-07-06 Po 13:32] =>  0:25
  CLOCK: [2020-07-06 Po 12:13]--[2020-07-06 Po 12:38] =>  0:25
  CLOCK: [2020-07-04 So 17:10]--[2020-07-04 So 17:35] =>  0:25
  CLOCK: [2020-07-04 So 09:24]--[2020-07-04 So 09:49] =>  0:25
  CLOCK: [2020-07-02 Čt 19:29]--[2020-07-02 Čt 19:54] =>  0:25
  CLOCK: [2020-07-02 Čt 00:04]--[2020-07-02 Čt 00:29] =>  0:25
  CLOCK: [2020-07-01 St 18:05]--[2020-07-01 St 18:30] =>  0:25
  CLOCK: [2020-06-29 Po 12:21]--[2020-06-29 Po 12:46] =>  0:25
  CLOCK: [2020-06-29 Po 11:27]--[2020-06-29 Po 11:52] =>  0:25
  CLOCK: [2020-06-29 Po 10:30]--[2020-06-29 Po 10:55] =>  0:25
  CLOCK: [2020-06-27 So 11:10]--[2020-06-27 So 11:35] =>  0:25
  CLOCK: [2020-06-26 Pá 17:49]--[2020-06-26 Pá 18:14] =>  0:25
  CLOCK: [2020-06-26 Pá 17:09]--[2020-06-26 Pá 17:34] =>  0:25
  CLOCK: [2020-06-26 Pá 16:39]--[2020-06-26 Pá 17:04] =>  0:25
  CLOCK: [2020-06-24 St 08:33]--[2020-06-24 St 08:58] =>  0:25
  CLOCK: [2020-06-23 Út 15:36]--[2020-06-23 Út 16:01] =>  0:25
  CLOCK: [2020-06-23 Út 15:02]--[2020-06-23 Út 15:27] =>  0:25
  CLOCK: [2020-06-23 Út 09:42]--[2020-06-23 Út 10:07] =>  0:25
  CLOCK: [2020-06-23 Út 09:01]--[2020-06-23 Út 09:27] =>  0:25
  CLOCK: [2020-06-23 Út 08:25]--[2020-06-23 Út 08:50] =>  0:25
  CLOCK: [2020-06-22 Po 18:08]--[2020-06-22 Po 18:33] =>  0:25
  CLOCK: [2020-06-22 Po 16:44]--[2020-06-22 Po 17:09] =>  0:25
  :END:

