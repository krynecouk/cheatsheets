* Installation
** =rustup=
   #+BEGIN_SRC
   $ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
   #+END_SRC

* Commands
  - ~rustup update~
  - ~rustup doc~
  - ~cargo new project~
  - ~cargo build~
  - ~cargo run~
  - ~cargo check~
  - ~cargo doc --open~
  - ~cargo test~
  - ~cargo test <name of test>~
  - ~cargo test <prefix of tests>~
    
* Variable vs. Constant
  By default everything is immutable. ~mut~ makes variable mutable. ~const~ must have type annotation and be known by compile time.

  - ~let x = 10;~                  // immutable
  - ~let mut x = 10;~              // mutable
  - ~const MAX_POINTS: u32 = 100;~ // constant

* Variable Shadowing 
  #+BEGIN_SRC rust
  fn main() {
      let x = 5;
      let x = x + 1; // ok
      x = 7; // not ok
  }
  #+END_SRC

* Data Types
** Scalar
   - Integer
   - Floating-point number
   - Boolean
   - Char

*** Integer
    Signed numbers are stored using two‚Äôs complement representation (e.g. i8 is from -128 to 127, u8 0 to 255).

    |---------+--------+----------+
    | Length  | Signed | Unsigned |
    |---------+--------+----------+
    | 8-bit   | i8     | u8       |
    | 16-bit  | i16    | u16      |
    | 32-bit  | i32    | u32      |
    | 64-bit  | i64    | u64      |
    | 128-bit | i128   | u128     |
    | arch    | isize  | usize    |
    |---------+--------+----------+
    
*** Floating-Point Types
    Default is ~f64~.

    |---------+-------+
    | Length  | Type  |
    |---------+-------+
    | 32-bit  | f32   |
    | 64-bit  | f64   |
    |---------+-------+

*** Boolean
    One byte in size.
    
    #+BEGIN_SRC rust
    fn main() {
        let t = true;
        let f: bool = false; // with explicit type annotation
    }
    #+END_SRC

*** Char
    Rust‚Äôs char type is four bytes in size and represents a Unicode Scalar Value.

    #+BEGIN_SRC rust
    fn main() {
        let c = 'z';
        let z = '‚Ñ§';
        let heart_eyed_cat = 'üòª';
    }
    #+END_SRC

** Compound
   - Tuple
   - Array

*** Tuple
    Can't grow or shrink.

    #+BEGIN_SRC rust
    fn main() {
        let tup: (i32, f64, u8) = (500, 6.4, 1);
        let tup = (500, 6.4, 1);
        let (x, y, z) = tup;
        println!(tup.x);
    }
    #+END_SRC

*** Array
    Can't grow or shrink (unlike ~Vector~).

    #+BEGIN_SRC rust
    fn main() {
        let a = [1, 2, 3, 4, 5];
        let a: [i32; 5] = [1, 2, 3, 4, 5];
        let a = [3; 5];
        let first = a[0];  // 3
        let second = a[1]; // 3
    }
    #+END_SRC

*** Functions
    Rust is a expression based language.

**** Statement
     Instructions that perform some action and do not return a value.

     #+BEGIN_SRC rust
     fn main() {    // statement
         let y = 6; // statement
     }
     #+END_SRC

**** Expressions
     Expressions evaluate to a resulting value.

     #+BEGIN_SRC rust
     fn main() {
         let x = 5;
         let y = {
             let x = 3;
             x + 1 // !!! without ; otherwise statement
         };
         println!("The value of y is: {}", y);
     }
     #+END_SRC

**** Return Value
     #+BEGIN_SRC rust
     fn five() -> i32 {
         5
     }
     fn plus_one(x: i32) -> i32 {
         x + 1         // !no ; ok
     }
     fn plus_one(x: i32) -> i32 {
         return x + 1; // ok
     }
     #+END_SRC
* Control Flow
  - if
  - loop
  - while
  - for

** ~if~
   #+BEGIN_SRC rust
   fn main() {
       let number = 6;
       if number % 4 == 0 {
           println!("number is divisible by 4");
       } else if number % 3 == 0 {
           println!("number is divisible by 3");
       } else {
           println!("number is not divisible by 4, 3, or 2");
       }
       let number = if 5 == 5 { 5 } else { 6 };
   }
   #+END_SRC

** ~loop~
   Loop until explicit stop.
   
   #+BEGIN_SRC rust
   fn main() {
       let mut counter = 0;
       let result = loop {
           counter += 1;
           if counter == 10 {
               break counter * 2;
           }
       };
       println!("The result is {}", result);
   }
   #+END_SRC

** ~while~
   #+BEGIN_SRC rust
   fn main() {
       let mut number = 3;
       while number != 0 {
           println!("{}!", number);
           number -= 1;
       }
       println!("LIFTOFF!!!");
   }
   #+END_SRC

** ~for~

   #+BEGIN_SRC rust
   fn main() {
       let a = [10, 20, 30, 40, 50];
       for element in a.iter() {
           println!("the value is: {}", element);
       }
   }
   #+END_SRC

   #+BEGIN_SRC rust
   fn main() {
       for number in (1..4).rev() {
           println!("{}!", number);
       }
       println!("LIFTOFF!!!");
   }
   #+END_SRC
** ~match~
   Pattern matching +operator+ expression.
   #+BEGIN_SRC 
   match <expression> {
      <pattern> => <some code>
   }
   #+END_SRC

   #+BEGIN_SRC rust
   fn main() {
       fn plus_one(x: Option<i32>) -> Option<i32> {
           match x {
               None => None,
               Some(i) => Some(i + 1),
           }
       }
   
       let five = Some(5);
       let six = plus_one(five);
       let none = plus_one(None);
   }
   #+END_SRC
** ~if let~
   Shorthand for ~match~ with only one pattern.
   #+BEGIN_SRC 
   if let <pattern> = <expression> {<some code>}
   #+END_SRC
   This:
   #+BEGIN_SRC rust
   fn main() {
       let some_u8_value = Some(0u8);
       match some_u8_value {
           Some(3) => println!("three"),
           _ => (),
       }
   }
   #+END_SRC
   Is same as this:
   #+BEGIN_SRC rust
   fn main() {
       let some_u8_value = Some(0u8);
       if let Some(3) = some_u8_value {
          println!("three")
       } else {
          ...
       }
   }
   
   #+END_SRC
* Ownership
  Rules of managing parts of heap memory that are no longer needed. For every value in heap there is only one variable on stack (owner of the value).
** Rules
   - Each value in Rust has a variable that‚Äôs called its owner.
   - There can only be one owner at a time.
   - When the owner goes out of scope, the value will be dropped (by calling ~drop~).

     #+BEGIN_SRC rust
     fn main() {
         let s1 = String::from("hello");
         let s2 = s1;
         println!("{}, world!", s1);
     }
     #+END_SRC
     #+BEGIN_SRC sh
     $ cargo run
        Compiling ownership v0.1.0 (file:///projects/ownership)
     error[E0382]: borrow of moved value: `s1`
      --> src/main.rs:5:28
       |
     2 |     let s1 = String::from("hello");
       |         -- move occurs because `s1` has type `std::string::String`, which does not implement the `Copy` trait
     3 |     let s2 = s1;
       |              -- value moved here
     4 | 
     5 |     println!("{}, world!", s1);
       |                            ^^ value borrowed here after move

     error: aborting due to previous error

     For more information about this error, try `rustc --explain E0382`.
     error: could not compile `ownership`.

     To learn more, run the command again with --verbose.
     #+END_SRC

     The concept of copying the pointer, length, and capacity without copying the data probably sounds like making a shallow copy. But because Rust also invalidates the first variable, instead of being called a shallow copy, it‚Äôs known as a move. In this example, we would say that s1 was moved into s2.

** Ownership and Functions
   Passing a variable to a function will move or copy, just as assignment does.
   #+BEGIN_SRC rust
   fn main() {
       let s = String::from("hello");  // s comes into scope
       takes_ownership(s);             // s's value moves into the function...
                                       // ... and so is no longer valid here
       let x = 5;                      // x comes into scope
       makes_copy(x);                  // x would move into the function,
                                       // but i32 is Copy, so it‚Äôs okay to still
                                       // use x afterward
   } // Here, x goes out of scope, then s. But because s's value was moved, nothing
     // special happens.
   
   fn takes_ownership(some_string: String) { // some_string comes into scope
       println!("{}", some_string);
   } // Here, some_string goes out of scope and `drop` is called. The backing
     // memory is freed.
   
   fn makes_copy(some_integer: i32) { // some_integer comes into scope
       println!("{}", some_integer);
   } // Here, some_integer goes out of scope. Nothing special happens.
   #+END_SRC

** Returns Values and Scope
   Returning values can also transfer ownership. The ownership of a variable follows the same pattern every time: assigning a value to another variable moves it. When a variable that includes data on the heap goes out of scope, the value will be cleaned up by drop unless the data has been moved to be owned by another variable.
   #+BEGIN_SRC rust
   fn main() {
       let s1 = gives_ownership();         // gives_ownership moves its return
                                           // value into s1
       let s2 = String::from("hello");     // s2 comes into scope
       let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                           // takes_and_gives_back, which also
                                           // moves its return value into s3
   } // Here, s3 goes out of scope and is dropped. s2 goes out of scope but was
     // moved, so nothing happens. s1 goes out of scope and is dropped.
   
   fn gives_ownership() -> String {             // gives_ownership will move its
                                                // return value into the function
                                                // that calls it
       let some_string = String::from("hello"); // some_string comes into scope
       some_string                              // some_string is returned and
                                                // moves out to the calling
                                                // function
   }
   
   // takes_and_gives_back will take a String and return one
   fn takes_and_gives_back(a_string: String) -> String { // a_string comes into
                                                         // scope
       a_string  // a_string is returned and moves out to the calling function
   }
   #+END_SRC

* References and Borowing
  References allow you to refer to some value without taking ownership of it. Because it does not own it, the value it points to will not be dropped when the reference goes out of scope.
  
  #+BEGIN_SRC rust
  fn main() {
      let s1 = String::from("hello");
      let len = calculate_length(&s1);
      println!("The length of '{}' is {}.", s1, len);
  }
  
  fn calculate_length(s: &String) -> usize { // s is a reference to a String
      s.len()
  } // Here, s goes out of scope. But because it does not have ownership of what
    // it refers to, nothing happens.
  #+END_SRC

** Rules
   - At any given time, you can have either one mutable reference or any number of immutable references.
   - References must always be valid (must have value to borrow from).

   #+BEGIN_SRC rust
   fn main() {
       let mut s = String::from("hello");
       let r1 = &mut s;
       let r2 = &mut s;
       println!("{}, {}", r1, r2); // error[E0499]: cannot borrow `s` as mutable more than once at a time
   }
   #+END_SRC

* Slices
  Reference to a contiguous sequence of elements in a collection rather than the whole collection.
** String Slice
   A string slice is a reference to part of a String.
   
   String slices are when using:
   - ranges
   - literals (stored in binary as sequence of strings)
   
   #+BEGIN_SRC rust
   fn main() {
       let s = String::from("hello world");
       let hello = &s[0..5];
       let world = &s[6..11];
   }
   #+END_SRC

** Array Slice
   #+BEGIN_SRC rust
   let a = [1, 2, 3, 4, 5];
   let slice = &a[1..3];
   #+END_SRC

* Structs 
  Object definition (structure). Unlike tuples, strucs attribute doesn't have to be in the same order.

** Struct Types
   - basic struct
   - tuple struct
   - unit-like struct

*** Basic Struct
  
    #+BEGIN_SRC rust
    ...
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
    ...
    #+END_SRC

**** Update Syntax (spread)
     #+BEGIN_SRC rust
     ...
     let user1 = User {
         email: String::from("someone@example.com"),
         username: String::from("someusername123"),
         active: true,
         sign_in_count: 1,
     };
   
     let user2 = User {
         email: String::from("another@example.com"),
         username: String::from("anotherusername567"),
         ..user1
     };
     ...
     #+END_SRC

*** Tuple Struct
    Struct with name but don‚Äôt have names associated with their fields; rather, they just have the types of the fields.

    #+BEGIN_SRC rust
    fn main() {
        struct Color(i32, i32, i32);
        let black = Color(0, 0, 0);
    }
    #+END_SRC

*** Unit-like Struct
    Struct without any field.

** Struct Methods
   #+BEGIN_SRC rust
   struct Rectangle {
       width: u32,
       height: u32,
   }
   impl Rectangle {
       fn can_hold(&self, other: &Rectangle) -> bool {
           self.width > other.width && self.height > other.height
       }
   }
   fn main() {
       let rect1 = Rectangle {
           width: 30,
           height: 50,
       };
       let rect2 = Rectangle {
           width: 10,
           height: 40,
       };

       println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
   }
   #+END_SRC

*** Automatic (De)Referencing
    Here‚Äôs how it works: when you call a method with object.something(), Rust automatically adds in &, &mut, or * so object matches the signature of the method. In other words, the following are the same:
    #+BEGIN_SRC rust
    p1.distance(&p2);
    (&p1).distance(&p2);
    #+END_SRC

** Associated Functions
   Like ~static~. Recognized by missing ~self~.

   #+BEGIN_SRC rust
   struct Rectangle {
       width: u32,
       height: u32,
   }
    
   impl Rectangle {
       fn square(size: u32) -> Rectangle {
           Rectangle {
               width: size,
               height: size,
           }
       }
   }
    
   fn main() {
       let sq = Rectangle::square(3);
   }
   #+END_SRC

* Enums 
  #+BEGIN_SRC rust
  fn main() {
      enum Message {
          Quit,
          Move { x: i32, y: i32 },
          Write(String),
          ChangeColor(i32, i32, i32),
      }
  
      impl Message {
          fn call(&self) {
              // method body would be defined here
          }
      }
  
      let m = Message::Write(String::from("hello"));
      m.call();
  }
  #+END_SRC

* Packages, crates and modules 
  - Packages: A Cargo feature that lets you build, test, and share crates
  - Crates: A tree of modules that produces a library or executable
  - Modules and use: Let you control the organization, scope, and privacy of paths
  - Paths: A way of naming an item, such as a struct, function, or module

** Packages
   A package is one or more crates that provide a set of functionality. A package contains a Cargo.toml file that describes how to build those crates.
*** Rules
    - package *must* contain 0 or 1 library crate;
    - package *can* contain 0 or N binary crates;
    - package *must* contain at least 1 crate (either library or binary);

** Crate
   A crate is a binary or library.
*** Rules
    - if ~main.rs~ then it's binary crate;
    - if ~lib.rs~ then its's library crate;
    - both are =crate-roots=

** Modules
   Modules let us organize code within a crate into groups for readability and easy reuse.
   
   #+BEGIN_SRC rust
   mod front_of_house {
       mod hosting {
           fn add_to_waitlist() {}
           fn seat_at_table() {}
       }
   
       mod serving {
           fn take_order() {}
           fn serve_order() {}
           fn take_payment() {}
       }
   }
   #+END_SRC
   
   Represents module tree:
   #+BEGIN_SRC 
   crate
    ‚îî‚îÄ‚îÄ front_of_house
        ‚îú‚îÄ‚îÄ hosting
        ‚îÇ   ‚îú‚îÄ‚îÄ add_to_waitlist
        ‚îÇ   ‚îî‚îÄ‚îÄ seat_at_table
        ‚îî‚îÄ‚îÄ serving
            ‚îú‚îÄ‚îÄ take_order
            ‚îú‚îÄ‚îÄ serve_order
            ‚îî‚îÄ‚îÄ take_payment
   #+END_SRC

** Path
   Way of finding item in module tree.

*** Absolute
    Starts from a crate root by using a crate name or a literal crate.
    
    #+BEGIN_SRC rust
     pub fn eat_at_restaurant() {
         // Absolute path
         crate::front_of_house::hosting::add_to_waitlist();
     }
    #+END_SRC

*** Relative
    Starts from the current module and uses self, super, or an identifier in the current module.
     
    #+BEGIN_SRC rust
     pub fn eat_at_restaurant() {
         // Relative path
         front_of_house::hosting::add_to_waitlist();
     }
    #+END_SRC

**** ~super~
     Analogy to ~..~ in shell.

**** ~self~
     Analogy to ~.~ in shell.

*** ~pub~ keyword
    All items are private by default. Parent module can't see to the child module. Child module can access parent. In order to expose parts of module, use ~pub~.

*** ~use~ keyword
    Adding use and a path in a scope is similar to creating a symbolic link in the filesystem.

    #+BEGIN_SRC rust
    use std::fmt::Result;
    pub use std::io::Result as IoResult;
    #+END_SRC

*** nested ~use~ paths
    #+BEGIN_SRC rust
    use std::cmp::Ordering;
    use std::io;
    #+END_SRC
    
    Is the same as:
    #+BEGIN_SRC rust
    use std::{cmp::Ordering, io};
    #+END_SRC

*** glob ~use~ operator
    #+BEGIN_SRC rust
    use std::collections::*;
    #+END_SRC

*** ~mod~ without ~{}~
    Loads content of different module. Must be included in ~use~ of module in different file.
    
    #+BEGIN_SRC rust
    mod front_of_house;
    pub use crate::front_of_house::hosting;
    #+END_SRC
* Collections
  - Vector
  - String
  - Hash Map
** Vector
   List of elements of the same type.
   
   #+BEGIN_SRC rust
   fn main() {
       let v1: Vec<i32> = Vec::new();
       let v2 = vec![1, 2, 3];
       let mut v3 = Vec::new();
       v3.push(5);
       let does_not_exist = &v2[100];    // panic
       let does_not_exist = v2.get(100); // None

       for i in &v2 {
           println!("{}", i);
       }
   }
   #+END_SRC
** String
   Rust core lang uses and knows *only* /string slice/ (~str~ or in borrowed form ~&str~). Reference to some UTF-8 encoded string in binary.

   ~String~ type comes from ~std~ library. Represents growable, mutable, owned, UTF-8 encoded string type. There are another string types in ~std~ like ~OsString~, ~OsStr~, ~CString~ and ~CStr~.
   
   ~String~ is just a wrapper aroud ~Vec<u8>~.
   
   ~String~ is represented as bytes, scalar values or grapheme clusters. That is the reason why rust don't know how to index ~String~ (which form of string?).
   
   #+BEGIN_SRC rust
   let mut s1 = String::from("foo");
   let s2 = "bar";
   s1.push_str(s2);
   println!("s2 is {}", s2);

   let s1 = String::from("tic");
   let s2 = String::from("tac");
   let s3 = String::from("toe");
   let s = format!("{}-{}-{}", s1, s2, s3);

   let hello = "–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ";
   // let answer = &hello[0]; // compile error
   hello.chars(); // ok
   hello.bytes(); // ok
   #+END_SRC

** Hash Map
   The type ~HashMap<K, V>~ stores a mapping of keys of type K to values of type V.
   
   #+BEGIN_SRC rust
   fn main() {
       use std::collections::HashMap;
       let mut scores = HashMap::new();
       scores.insert(String::from("Yellow"), 50);
       scores.entry(String::from("Yellow")).or_insert(50); // check if exists and if not then insert
   }
   #+END_SRC

* Error Handling 
  - Unrecoverable (~!panic~)
  - Recoverable (~Result<T, E>~)

** Unrecoverable (~!panic~)
   Print a failure message, unwind and clean up the stack, and then quit.
   
   #+BEGIN_SRC rust
   fn main() {
       panic!("crash and burn");
   }
   #+END_SRC
   
   #+BEGIN_SRC shell
   $ RUST_BACKTRACE=1 cargo run
   #+END_SRC

** Recoverable (~Result<T, E>~)
   #+BEGIN_SRC rust
   enum Result<T, E> {
       Ok(T),
       Err(E),
   }
   #+END_SRC
   
   #+BEGIN_SRC rust
   use std::fs::File;
   use std::io::ErrorKind;
   
   fn main() {
       let f = File::open("hello.txt");
       let f = match f {
           Ok(file) => file,
           Err(error) => match error.kind() {
               ErrorKind::NotFound => match File::create("hello.txt") {
                   Ok(fc) => fc,
                   Err(e) => panic!("Problem creating the file: {:?}", e),
               },
               other_error => {
                   panic!("Problem opening the file: {:?}", other_error)
               }
           },
       };
   }
   #+END_SRC
*** ~unwrap~ and ~expect~
    #+BEGIN_SRC rust
    fn main() {
        let f = File::open("hello.txt").unwrap();
        let f = File::open("hello.txt").expect("Failed to open hello.txt");
    }
    #+END_SRC
*** propagate error operator ~?~
    If ~open~ returns ~Err~ then return from function ~read_username_from_file~ an ~Err~. Otherwise return ~Ok~.
    #+BEGIN_SRC rust
    use std::fs::File;
    use std::io;
    use std::io::Read;
    
    fn read_username_from_file() -> Result<String, io::Error> {
        let mut s = String::new();
    
        File::open("hello.txt")?.read_to_string(&mut s)?;
    
        Ok(s)
    }
    #+END_SRC

* Generic Types 
  #+BEGIN_SRC rust
  fn largest<T>(list: &[T]) -> T {...}

  struct Point<T> {
      x: T,
      y: T,
  }

  impl<T> Point<T> {
      fn x(&self) -> &T {
          &self.x
      }
  }
  #+END_SRC

* Trait
  A trait tells the Rust compiler about functionality a particular type has and can share with other types (~interface).
  
  #+BEGIN_SRC rust
  #![allow(unused_variables)]
  trait Summary {
      fn summarize(&self) -> String;
  }

  trait DefaultSummary {
      fn summarize(&self) -> String {
          "foo".to_string();
      }
  }

  struct NewsArticle {
      pub headline: String,
      pub location: String,
      pub author: String,
      pub content: String,
  }

  impl Summary for NewsArticle {
      fn summarize(&self) -> String {
          format!("{}, by {} ({})", self.headline, self.author, self.location)
      }
  }

  // this
  fn notify(item: &impl Summary) {
      println!("Breaking news! {}", item.summarize());
  }

  // same as this
  fn notify<T: Summary>(item: &T) {
      println!("Breaking news! {}", item.summarize());
  }
  #+END_SRC

** Trait Bounds
   #+BEGIN_SRC rust
   // must implement ~Summary~ AND ~Display~
   pub fn notify(item: &(impl Summary + Display)) {}

   // same
   pub fn notify<T: Summary + Display>(item: &T) {}
   
   // with where trait bound
   fn some_function<T, U>(t: &T, u: &U) -> i32
       where T: Display + Clone,
             U: Clone + Debug
   {}
   #+END_SRC

** Blanket Implementations
   Implement a trait for any type that implements an another trait.
   
   #+BEGIN_SRC rust
   // Implement ~ToString~ for any ~is-a Display~
   impl<T: Display> ToString for T {}
   #+END_SRC

* Lifetimes
  Every reference in Rust has a /lifetime/, which is the scope for which that reference is valid.
  #+BEGIN_SRC rust
  fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
      if x.len() > y.len() {
          x
      } else {
          y
      }
  }
  #+END_SRC

** Borrow Checker
   Rust checks if the inner scopes lives long as the outer ones.
   - Short life
     #+BEGIN_SRC 
     fn main() {
         {
             let r;                // ---------+-- 'a
             {                     //          |
                 let x = 5;        // -+-- 'b  |
                 r = &x;           //  |       |
             }                     // -+       |
             println!("r: {}", r); //          |
         }                         // ---------+
     }
     #+END_SRC

   - Long life
     #+BEGIN_SRC rust
     fn main() {
         {
             let x = 5;            // ----------+-- 'b
                                   //           |
             let r = &x;           // --+-- 'a  |
                                   //   |       |
             println!("r: {}", r); //   |       |
         }                         // ----------+
     }
     #+END_SRC

** Lifetime Elision Rules
   1. Implicit lifetimes
      Every function gets an implicit lifetime.

   2. output lifetime
      If one input lifetime then the output's lifetime is the same.

   3. ~self~ lifetime
      If multiple input lifetimes but one is ~&self~ or ~&mut self~ then output lifetime is that of ~self~.

   4. other
      If none of above then the lifetime annotation must be specified.
* Testing
  - ~assert!~
    #+BEGIN_SRC rust
    #[cfg(test)]
    mod tests {
        use super::*;
        #[test]
        fn greeting_contains_name() {
            let result = greeting("Carol");
            assert!(
                result.contains("Carol"),
                "Greeting did not contain name, value was `{}`", result
            );
        }
    }
    #+END_SRC
  - ~assert_eq!~
    #+BEGIN_SRC rust
    pub fn add_two(a: i32) -> i32 {
        a + 2
    }
    
    #[cfg(test)]
    mod tests {
        use super::*;
    
        #[test]
        fn it_adds_two() {
            assert_eq!(4, add_two(2));
        }
    }
    #+END_SRC
  - ~assert_ne!~
  - ~[should_panic]~
    #+BEGIN_SRC rust
    #[test]
    #[should_panic(expected = "Guess value must be less than or equal to 100")]
    fn greater_than_100() {
        Guess::new(200);
    }
    #+END_SRC
  - ~[ignore]~
  - custom
    #+BEGIN_SRC rust
    #[test]
    fn it_works() -> Result<(), String> {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from("two plus two does not equal four"))
        }
    }
    #+END_SRC
** Unit
   - Small and more focused, testing one module in isolation at a time, and can test private interfaces.
   - In the code which testing (module ~tests~ with ~cfg(test)~).
     #+BEGIN_SRC rust
     fn main() {...}

     #[cfg(test)]
     mod tests {
         use super::*;
         #[test]
         ...
     }
     #+END_SRC
   - ~cfg(test)~ (configuration) tells compiler to not include test code in the build.
** Integration
   - Entirely external to your library and use your code in the same way any other external code would, using only the public interface and potentially exercising multiple modules per test.
   - In =crate/tests/<name>_test.rs=.
   - ~common~ functions must be in =tests/common/mod.rs=
     #+BEGIN_SRC rust
     mod common;
     
     #[test]
     fn it_adds_two() {
         common::setup();
         assert_eq!(4, adder::add_two(2));
     }
     #+END_SRC
    
* Sources 
  - [1]: [[https://doc.rust-lang.org/book/title-page.html][Rust Book]]
* Pomodoros
  :LOGBOOK:
  CLOCK: [2020-07-02 ƒåt 00:04]--[2020-07-02 ƒåt 00:29] =>  0:25
  CLOCK: [2020-07-01 St 18:05]--[2020-07-01 St 18:30] =>  0:25
  CLOCK: [2020-06-29 Po 12:21]--[2020-06-29 Po 12:46] =>  0:25
  CLOCK: [2020-06-29 Po 11:27]--[2020-06-29 Po 11:52] =>  0:25
  CLOCK: [2020-06-29 Po 10:30]--[2020-06-29 Po 10:55] =>  0:25
  CLOCK: [2020-06-27 So 11:10]--[2020-06-27 So 11:35] =>  0:25
  CLOCK: [2020-06-26 P√° 17:49]--[2020-06-26 P√° 18:14] =>  0:25
  CLOCK: [2020-06-26 P√° 17:09]--[2020-06-26 P√° 17:34] =>  0:25
  CLOCK: [2020-06-26 P√° 16:39]--[2020-06-26 P√° 17:04] =>  0:25
  CLOCK: [2020-06-24 St 08:33]--[2020-06-24 St 08:58] =>  0:25
  CLOCK: [2020-06-23 √öt 15:36]--[2020-06-23 √öt 16:01] =>  0:25
  CLOCK: [2020-06-23 √öt 15:02]--[2020-06-23 √öt 15:27] =>  0:25
  CLOCK: [2020-06-23 √öt 09:42]--[2020-06-23 √öt 10:07] =>  0:25
  CLOCK: [2020-06-23 √öt 09:01]--[2020-06-23 √öt 09:27] =>  0:25
  CLOCK: [2020-06-23 √öt 08:25]--[2020-06-23 √öt 08:50] =>  0:25
  CLOCK: [2020-06-22 Po 18:08]--[2020-06-22 Po 18:33] =>  0:25
  CLOCK: [2020-06-22 Po 16:44]--[2020-06-22 Po 17:09] =>  0:25
  :END:

